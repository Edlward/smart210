
comamd line tag list

device tree 

/************************** MMU ***************************/

linux zimage镜像可拆分为硬件部分和内核部分
内核为了效率工作,和让开发者更有效率地维护,往往使用虚拟内存的方法来访问内存
内核只认识虚拟地址,工作在32位系统的内核,把虚拟地址 0xc000000 - 0xffffffff 地址的内存划分为内核内存区,就是内核函数使用的内存
而 0x0 - 0xbfffffff 划分为用户内存区,即用户函数使用的内存区域. 
所以乍一看,以为运行 32位 linux 一定要带4gb内存,其实并不

上述可以理解为, 32位 linux 系统 运行时, 只有一个内核维护进程 和 有多个用户进程
用户进程遇到一些硬件操作等底层操作时会传递请求让内核维护进程具体执行,得到结果后返回用户进程
此外,内核维护进程还会按规则 切换 执行中的用户进程
内核维护进程访问的虚拟内存域是 地址 0xc000000 - 0xffffffff
而每一个用户进程访问的虚拟内存域是 地址 0xc000000 - 0xffffffff (注意,不是所有用户进程共用这个域,而是互相独立拥有)
如 用户进程A 与 用户进程B 都有一个自己的虚拟内存域,地址 0x0 - 0xbfffffff
用户进程A 与 用户进程B 都有各自 的虚拟地址 如都有各自的 0x1000

内核部分只管使用这样的虚拟程序,然而是硬件部分完成了虚拟地址与物理地址的转化

满足内核使用虚拟内存的要求,于是诞生了MMU这样的完成虚拟地址与硬件地址转化的硬件模块,

cpu 读写一个内存地址时,直接操作了对应的内存硬件地址时, cpu读写的内存地址则是真正的物理地址.
cpu 读写一个内存地址时,而mmu功能又打开了,则是操作了MMU,mmu转化了这个地址,并惭怍得到的真实内存硬件地址,cpu读写的内存地址则是虚拟地址.
所以 zimage镜像启动时会先启动初始化mmu,然后才真正初始化内核,和启动内核维护进程. 

mmu工作原理:
在一个进程执行中,cpu要访问一个虚拟地址d,
mmu现在挂着这个进程 专属的 一级准换表,mmu接到cpu访问操作后,开始分析这个虚拟地址,
虚拟地址d 的 [31:20] 放着的内容是 某个 一级准换表项(如一级准换表项D) 相对于一级准换表 的第一个一级准换表项的位置.
所以根据这个偏移位置,我们找到了 一级准换表项D,
一级准换表项D 是一个32位数据,告诉我们这个 虚拟地址d 如何转换
一级准换表项D 的 [1:0] 告诉转换方式:
	[1:0]= 00 表示无效的转换,mmu转换失败,内核维护进程检测到错误,触发缺页异常
	[1:0]= 01 表示粗页转换方式
	[1:0]= 10 表示	段转换方式
	[1:0]= 01 表示细页转换方式
秦静分析:
假如:	一级准换表项D的[1:0]	表示 段转换方式
	一级准换表项D的[31:20]	存放了某个物理内存段dd的基地址,一个物理内存段大小是1mb
	虚拟地址d的[19:0]	存放了某个物理内存单元DD,基于物理内存段dd的基地址 的偏移位置
	映射到的物理内存DD	便是 一级准换表项D的[31:20] 与 虚拟内存d的[19:0] 组成的32位地址
假如:	一级准换表项D的[1:0]	表示 细页转换方式
	一级准换表项D的[31:12]	存放了某个 细页页表oo的基地址, 细页页表里每个页项都是32位数据
	虚拟内存d的[19:0]	存放了某个 细页页表项OO,基于细页页表oo的基地址 的偏移位置
	我们找到这个 细页页表项OO
	细页页表项OO的[31:12]	存放了某个物理页的基地址kk, 一个物理内存也4kb
	虚拟地址d的[11:0]	存放了某个物理内存单元KK,基于物理内存页kk的基地址 的偏移位置
	映射到的物理内存KK	便是 细页页表项OO的[31:12] 与 虚拟内存d的[11:0] 组成的32位地址
粗页转换方式分析略!!
最后,	cpu读虚拟内存内容,mmu会把映射到的物理地址上的内容返回cpu,
	cpu写虚拟内存聂荣,mmu会写到映射的物理地址上

所以要使用mmu;
	先按情况建立一级转换表,
	然后把表的基地址挂到mmu,把基地址写入 cp15协处理器->c2寄存器,即相当于把基地址挂到mmu上
	最后打开mmu开关
裸机开发情况下,开发者自己填钻换表,
linux程序开发下,内核维护程序会自动为每一个新的用户进程算法生成专属一级转换表

内核运行时当建立一个新用户进程D时,会通过算法生成一个一级转换表放在内核区内存区里,并把这个新用户进程D的一级转换表的基地址,更新到cp15-c2寄存器.
如果用户进程D使用细页转换方式,还会另外算法生成一堆 细页页表
这样,这个新用户进程D便安照这个表,通过mmu把虚拟内存映射到物理内存里,
当然映射出来的地址,第一次使用前先检测是否已经被其他进程使用,内核会把被已被分配占用的物理内存的区域信息记录在内核内存区,方便检测.
如果检测到已被使用,就出现缺页异常,内核维护进程为此纠改用户进程D转换表表项,然后重新映射,重新检测,不断重复,直到成功隐射到未被使用的物理内存
出来的效果是进程D 与进程A 相同虚拟地址 0x100 的值却不一样,因为,映射到不同地址.
也就是说,每个用户进程都有自己的一级转换表(由内核维护进程建立,放在内核内存区)和一级转换表的基地址(TTB),切换进程时,会把对应的TTB挂好给mmu使用.
用户进程们虽然都有自己一套互不关系独立的虚拟内存域,但是,用户进程们公用一个物理内存域,所以,各自有一套复杂的,由算法生成的转换表.
而内核维护进程不同,有一个自己专用的物理内存域,不需要公用,所以纵使也要使用MMU隐射,却是简单直接映射,所以转换表是符合直接隐射的简单表格
用户进程虚拟内存能达3GB 内核维护进程的虚拟内存也有1GB,但是真正的物理内存却没有这么多,所以,再大的虚拟内存地址也只能映射有限的物理内存地址里

/************************** 总线_设备_设备驱动组成的模型框架 ***************************/

总线:	
描述结构数据 bus_type{
		*name /*总线名称*/
		*mach /*匹配函数,主要匹配设备驱动与设备的名字*/
		...
		)
总线注册:bus_register();   /*注册到linux里,注册后,/sys/bus/ 目录里有其总线文件夹*/
总线注销:bus_unregister(); /*注销函数*/

设备驱动:
描述结构数据 device_drive{
		*name /*设备名字*/
    bus_type	bus   /*所属总线*/
		probe /*初始化函数*/
		...
		}
设备驱动注册:driver_register  /*注册设备驱动到总线上,注册后,/sys/bus/某自定义总线/driver/ 目录下有对应驱动文件*/
设备驱动注册:driver_unregister /*注销函数*/

设备:
描述结构数据 device{
		init_name /*设备名字,device_register后,会把init_name拷到 kobj.name里去,并置init_name为NULL*/
    bus_type	bus   	  /*所属总线*/
		...
		}
设备注册:device_register  /*注册设备到总线上,注册后,/sys/bus/某自定义总线/device/ 目录下有对应设备文件记录着设备的相关信息*/
设备注册:device_unregister /*注销函数*/

设备,设备驱动,总线虽然框架内容结构不一样,但是对于linux看,都各自为一个模块,使用 module_init, module_exit 装入linux,
总线,module_init里执行bus_register()把一条总线注册到linux的总线子系统里 			(insmod xxbus.ko)
设备,module_init里执行device_register()把一个设备及相关信息注册到指定总线的设备链表里	(insmod xx0dev.ko)
设备驱动,module_init里执行driver_register()把一个设备驱动注册到指定总线的设备链表里	(insmod xx0drv.ko)

当一个 设备/设备驱动 注册到总线上时,该总线被触发匹配该 设备/设备驱动 到 现有的其他 设备驱动/设备,
成功匹配后,会执行设备驱动的probe初始化,初始化设备,注册并映射到一个 逻辑设备 甚至建立/dev/里的逻辑设备点文件,
用户程序通过操作这个文件来操作设备
即 insmod bus.ko 后,不过是 insmod driver.ko 或是 insmod device.ko ,都会触发bus匹配函数.匹配新加入设备/设备驱动与已存在的.

/dev/里的逻辑设备点文件 与 /sys/bus/某自定义总线/device/ 目录下有对应设备文件 性质不一样
另外注意写 bus mach 函数时,匹配名字,是匹配 drv->name 与 dev->kobj.name


//////////////逻辑设备
这一模型其实应该还有一块 逻辑设备的 内容概念
也就是说,设备驱动probe过程时,会根据设备特性注册一个映射的逻辑设备,甚至在/dev/生成逻辑设备点文件
逻辑设备包括 我们常常 说的 字符设备 块设备 网络设备,还有一些基于这3个基本组合的更复杂逻辑设备 
例如,混杂设备,其实就是字符设备的一种变种,主设备号为10
混杂设备描述结构数据:miscdevice{
			minor /*次设备号*/
			*name /*设备名*/
			*fops /*文件操作*/
			.../*剩下的内核操作,一般不用用户填写*/
			)
注册:misc_register()
所谓的设备号,主设备号,次设备号,都是描述逻辑设备的
注意,不是所以设备驱动都要挂入bus,所以也不用匹配设备信息成功后再初始化,
也有一些直接module_init就初始化的,
如led的驱动,module_init不用注册到某个bus,不用参与到跟一堆注册了的设备信息匹配,匹配成功后才初始化
module_init,(连硬件初始化操作也免掉),注册一个 逻辑字符设备led,(或者也可以注册为混杂设备) 并映射过去,只是未加入自动生成一个逻辑设备点的操作
insmod led.ko后,
mkmod /dev/led 生成逻辑设备点
然后就可,用一个用户程序来操作了(打开逻辑设备点文件,并执行广义的操作"打开/读/写")
(直接通过广义操作来实现操作及初始化硬件)






/************************** 平台设备 ***************************/

依然符合 总线_设备_设备驱动组成的模型框架 
只不过,linux 已经提供了 指定的 概念性质的 一条 platform_bus!! 
用户只需要写好这bus上的,platform_device 和 platform_driver 便可, 而且,数据结构格式添加跟多重要的必要项, 写设备 和 设备驱动更方便
几乎很多不同性质的设备,都可以使用通性的格式写出设备和设备驱动,并挂到platform_bus上工作.

平台设备驱动:
描述结构数据 platform_driver{
		*name /*设备名字*/
		probe /*初始化函数*/
		remove /*移除函数*/
		...
		}
设备驱动注册:platform_driver_register  /*注册设备驱动到总线上,注册后,/sys/bus/platform/driver/ 目录下有对应驱动文件*/
设备驱动注册:platform_driver_unregister /*注销函数*/

平台设备:
描述结构数据 device{
		init_name /*设备名字,device_register后,会把init_name拷到 kobj.name里去,并置init_name为NULL*/
		id	  /*platform bus 还提供了一种匹配id_table的方式 匹配平台设备与平/台设备驱动*/
		dev	  /*设备描述结构数据(这里引入一般性的设备描述结构数据,可提供更复杂的功能)*/
		num_resources /*设备资源的数量*/
		*resource /*设备资源的结构数据指针*/
		...
		}
设备资源的结构数据 resource (
			start	/*设备资源起始地址*/
			end	/*设备资源结束地址*/
			name
			flags	/*资源的类型*/
			parent,sibling,child
			...
			)
设备注册:platform_device_register  /*注册设备到总线上,注册后,/sys/bus/platform/device/ 目录下有对应设备文件记录着设备的相关信息*/
设备注册:platform_device_unregister /*注销函数*/

平台设备一般都是控制一些硬件总线类控制器的,如usb主机控制器,i2c主机控制器,dm900网卡,...

这里可能对linux的总线,与物理总线有所模糊
举个例子,usb子系统,linux实现有两种方式:
第一种:
主机写一个usb_bus,针对usb设备如鼠标,键盘,写对应的设备和设备驱动,
这里,不同功能的设备驱动操作内容包括操作usb主机控制器,和设备
我们知道,usb设备都接到usb主机控制器里,usb主机控制器相当于硬件bus,
而注册在linux的usb_bus只是一个虚拟符号信息,并没有实现控制usb主机控制器的功能
而控制usb主机控制器的功能,则写在每个设备驱动里,
而控制usb主机控制器的功能的内容代码大同小异,但是,每个usb设备驱动都要有一段
第二种:
把usb主机控制器作为一个平台设备挂到platform平台设备里,
就是把usb主机控制器独立出来
然后usb主机控制器平台注册到 linux 的 usb core
usb_bus也注册时,也多一项注册到 linux 的 usb core里
于是,有硬件插入时,usb core  便会通知 usb_bus 匹配
usb_bus上的usb设备驱动也不用加入控制usb主机控制器的内容,
只需要通过与usb_core 交互 urb 就可以达到控制设备的功能



/************************** I2c ***************************/

sda	数据信号
scl	时钟信号

使用i2c 通讯时,需要先发送8位设备地址:
[7:4]产商固定的id,[3:1]根据设备管脚电平状态确定的地址,所以是只7位,[0]表示接下来的下一个8位数据读写方向

sda与scl同时高电平,表示空闲状态
起始信号:scl仍然维持高电平,sda下降到低电平
结束信号:scl维持高电平,sda上升到高电平
数据传输:i2c协议以每8位为一单元地传输数据,包括发送8位设备地址(其中最后0位为读写标记位)
应答: 没传输完一单元数据,接收方得到控制sda线权利来发出应答信号,然后在把sda控制权返还发送方,
      接收方响应:sda低电平 ack 表示接收成功
		    高电平 nack 表示接收不成功

裸机开发
写中断:
对于2440芯片, 写入从设备地址写模式 在sat寄存器写入0xf0,然后硬件操作发送数据,等待返回ack后会触发中断.
然后每发送一单元数据是直接写到对应寄存器上,清除中断,然后硬件操作发送数据,等待返回ack后会触发中断.
(12c硬件操作比cpu主频要慢的多,所以cpu要等待ack产生,成功得到返回ack后会触发中断.
然后再实现中断函数,或者执行下一单元的发送)
读中断:
对于2440芯片, 写入从设备地址读模式 在sat寄存器写入0xb0,然后硬件操作发送数据,等待返回ack后,又开始等待一单元数据
当接受到完整的一个单元数据后自动返回ack并产生中断, 这时便可读出数据或者执行中断函数
清中断flag 便可以等待下单元数据
接收最后一位数据前,先设置下次返回nack信号,这时,当接受下一单元数据后自动返回nack,
然后设备就会执行结束信号

注意以上的中断flag有两个,一个是在i2c状态寄存器里,一个是在中断控制模块了,这里触发中断时两个flag都立下标记,
上述裸机过程清i2c状态寄存器的flag,中断函数则要清除中断控制模块里的flag,
不然无法产生下次中断,也就无法成功读出或写进下个单元的数据.

写操作: 从设备地址写模式 等ack 设备里的地址 等ack 要写入的数据 等ack 结束
读操作: 从设备地址写模式 等ack 设备里的地址 等ack 重新起始信号 从设备地址读模式 等ack 等待一单元数据 返回ack 等待一单元数据 返回ack .. 结束

linux i2c子系统

		用户程序			i2c用户模式驱动(应用程序)	i2c从设备驱动有两种方式
		   |				       |			1,用户自定义的i2c设备驱动
		i2c设备驱动			i2c-dev(通用i2c驱动)		2,使用linux通用的i2c-dev驱动,用户自定义i2c用户模式驱动
		   |				       |			
				i2c设备驱动(两个方式)				i2c设备驱动通过与i2c core交互来访问i2c设备
				    |
				 i2c core					i2c从设备驱动 与 i2c主机控制器驱动 都注册到i2c core
				    |
			adapter algorithm (i2c主机控制器驱动)			i2c主机控制器驱动 是作为平台驱动注册的
				    |						adaptor 描述总线控制器 algorithm 提供api给设备驱动访问设备
				i2c主机控制器

似乎平台设备驱动probe初始化,都不需要注册和映射一个/dev的设备点

使用linux通用的i2c-dev驱动,用户自定义i2c用户模式驱动(其实是一个用户程序不能算驱动):
linux通用的i2c-dev驱动,注册了逻辑设备点,/dev/i2c0,但是却没有初始化具体某个i2c硬件设备
此外通用的i2c-dev驱动构造了通用的message结构数据
用户模式驱动 打开逻辑设备点文件 填充通用的message结构数据,包含设备的地址 
通用驱动便会提交 i2c core 实现访问设备
所以用户模式驱动实现具体往哪个设备写什么样的数据

用户自定义的i2c设备驱动(参考AT24.c i2c通讯的eeprom)
通过匹配id.table,发现此函数适用于一堆硬件设备
初始化probe函数: 注册了一个逻辑设备点文件/sys/bus/i2c/devices/0-0050/eeprom,当往文件读写会映射到驱动注册的读写函数,从而访问设备
这些读写函数会构造一条条专用message消息框架,提交给i2c core 让i2c core 实现访问设备
用户程序只需要,打开设备点文件,简单使用读写函数,便能实现访问设备

注意 mach-s3c2440.c:machine_init()里只是注册了设备信息,并不是直接执行驱动的初始化probe
而在后面初始化中,内核会匹配驱动信息与设备信息,成功后才执行驱动的初始化probe


/************************** spi ***************************/
信号线:
主机:	ss	--	从机:	ss	片选信号线,主机模块其实有多根ss针 ,而每个spi设备只有一根,所以主机通过跟指定ss针信号指定spi设备
	mosi	--		simo	数据方向从主机到从机
	miso	--		somi	数据方向从从机到主机
	sck	--		sck	时钟信号-产生

主机spi配置
cpol决定时钟空闲时处于的电平状态,
cpha决定上升沿还是下降沿采样数据

操作spi:
		用户操作	  自动	      自动
	cpu写数据 --> tx_data寄存器 --> tx FIFO --> tx 移位寄存器	用户写数据前,要先检测FIFO是否已满
		用户操作	  自动	      自动
	cpu写数据 --> tx_data寄存器 --> tx FIFO --> tx 移位寄存器	用户读数据前,要先检测FIFO是否已空

spi中断:
	因为用户写入 tx_data寄存器 的数据会自动写入 tx FIFO 当 FIFO数据超过一定量时,可以配置触发中断函数,也意味FiFO数据已经很多了,
	因为用户读出 rx_data寄存器 的数据会自动提出 tx FIFO 当 FIFO数据少于一定量时,可以配置触发中断函数,也意味FiFO数据已经很少了,
	注意,这个一定量与FIFO的的总容量不是同一概念

注意,一个mcu硬件里可以有多个spi主机模块,那就意味着可以有多个spi主机控制器,有多条spi bus

linux spi子系统:
		spi core
	|			|
     spi设备驱动(m25p80.c) spi主机控制器驱动 (spi_s3c2410.c)
	...

分析 spi_s3c2410.c
spi主机控制器 在linux看来属于平台设备,所以,使用平台驱动相关api
spi主机控制器平台驱动初始化probe函数主要:初始化硬件,注册中断函数,然后把这个spi主机控制器注册到spi core上

分析 m25p80.c
spi设备,在linux看来,spi设备通过 驱动 与 spi core 交互 spi_message 结构体数据来实现对spi设备的访问
spi设备驱动初始化probe函数:初始化设备的操作指令,注册映射到逻辑设备,注册设备到spi core
spi_message 结构体 由由多个 spi_transfer结果体数据组成,每个tanfer结构数据代表一次数据的传输操作
例如 m25p80.c是一个spi filash 的驱动,
个flash写入数据,分成3步,输入指令,输入地址,输入数据,分成3个tanfer结构数据完成,
填写好的spi_message 结构体数据 通过 spi core api 函数 spi_sysc()来提交给spi core 处理.
最终把传递数据交到 spi主机控制器 的 te/rx 函数来传给 设备,完成spi_message 结构体数据的第一个数据传输,
后续数据通过注册的中断函数继续调用 te/rx 函数 来传输,直到完成

/************************** usb ***************************/

usb 1.0 5mbps
    1.1 12mbps		full speed
    2.0 480mbps		high speed
    3.0 10倍于2.0	superi speed

四线:	vcc	power
	D+	DATA+ PD+ USBDT+ 	交叉信号线: D+D-电压差 > 200mv 相当于信号1
	D-	DATA- PD- USBDT- 			      < 200mv 相当于信号0
	GND	地线
usb使用交叉信号传输方式,所以是半双工 传输协议,
这样说来,usb协议通过主机不断轮询设备,是否有数据要传输的机制便成立了!!
所以每次传输,所有传输都是主机主动联系的,而不是设备主动告诉主机的.

usb系统拓扑结构:
		  usb主机控制器
			|
	     设备1---根集线器 hub---设备2
		     |	      |
		集线器 hub   设备....
		|   |    |
	     设备3 设备4 设备...

usb的主机控制器有:
	ohci:嵌入式机器的usb主机控制器 使用usb1.1标准
	uhci:主流pc机器上的usb主机控制器 使用usb1.1标准
	ehci:兼容ohci 与 uhci 遵从usb2.0标准的主机控制器

usb协议分析:
		      	     设备					(usb设备的拓扑结构)	例如:
		|				|			usb媒体播放器,用usb线连到主机pc,可以播放pc里的媒体文件
	      配置1            	       	       配置2			播放器 有音乐播放, 和电影播放两种配置,
	|	|	|		|	|	|		默认登记 在pc上的usb主机控制器的配置是 电影播放
     接口1    接口2    接口...         接口1   接口2   接口....		电影播放配置 有 3个 接口, 视频流 声音流 以及控制流  
	|	|	|		|	|	|		视频流接口有两个端点,一个源视频流输入端点,一个视频效果数据输入端点
     端点0    端点0    端点0           端点0   端点0    端点0  		声音流接口有两个端点,一个源音频流输入端点,一个音频效果数据输入端点
         1                 1              1       1        1		控制流接口有两个端点,一个操作pc文件的控制数据输出端点,
		           2	                  2        2				    一个pc控制播放器的数据输出端点,
			   .			  . 			每个接口至少有一个端点,名称对应端口0
			   .     	          .			端点0 一般是pc控制数据的输入端点,也可以初始化为其他类型端点.
									每个端点只能标定为一个数据流方向,
									这种规定可能为了方便usb的半双工协议,主机轮询的机制有关

	每个 USB 设备 都因为其服务的性质可能有的多样性, 	而有多种配置 configurations
	每个 配置     都因为服务不同的具体内容,   	而有不同的接口 interfaces, 同一配置,可以有多个接口并行工作
	每个 接口     都因为数据具体传输方向和要求	而有多个端口 endpoints, 端口提供一种单向数据传输的管道,
							所以,同一接口,至少需要两个端口工作.
	每个 端口     都根据数据内容性质			而分为4种类型:控制、中断、批量、等时
							所以端口除了有方向性,也有数据内容性质的自身属性,
	控制传输:
		控制端点被用来控制对 USB 设备的不同部分访问.
		通常用作配置设备、获取设备信息、发送命令到设备或获取设备状态报告。
		这些端点通常较小,每个 USB 设备都有一个控制端点称为"端点 0", 被 USB core 用来在插入时配置设备。
		USB协议保证总有足够的带宽留给控制端点传送数据到设备.
	中断传输: 
		每当 USB 主机向设备请求数据时，中断端点以固定的速率传送小量的数据
		此为USB 键盘和鼠标的主要的数据传送方法。它还用以传送数据到 USB 设备来控制设备.
		通常不用来传送大量数据。USB协议保证总有足够的带宽留给中断端点传送数据到设备.
	批量BULK传输:
		批量端点用以传送大量数据。
		这些端点常比中断端点大得多. 它们普遍用于不能有任何数据丢失的数据。
		USB 协议不保证传输在特定时间范围内完成。
		如果总线上没有足够的空间来发送整个BULK包，它被分为多个包进行传输
		这些端点普遍用于打印机、USB Mass Storage和USB网络设备上。
	等时ISOCHRONOUS传输:
		等时端点也批量传送大量数据, 但是这个数据不被保证能送达。
		这些端点用在可以处理数据丢失的设备中，并且更多依赖于保持持续的数据流.
		如音频和视频设备等等。



usb 枚举
当一个usb设备插入到hub口时,主机控制器检测到新设备,并会通过访问标准的一个默认端口0来获取usb设备的一系列信息
每个usb设备都会有一块储存芯片存放usb设备的相关信息;存放着usb设备的逻辑结构
	每个设备都有	一个设备描述符			18个字节
			多个配置描述符 每个配置描述符 	 8个字节
			多个接口描述符 每个接口描述符 	 8个字节
			多个端口描述符 每个端口描述符 	 7个字节

usb 主机端结构
	     usb驱动
		|
	     usb core		(内核处理 usb协议的内容)
		|
	  usb主机控制器驱动
		|
	   usb主机控制器

usb 设备端结构
	    gadget驱动
		|
	    gadget API 
		|
	     UDC 驱动
		|
	    usb 设备控制


USB 总线概念:
	一个 USB 总线引出两个重要的链表，一个为 USB 设备链表，一个为 USB 驱动链表。
	USB设备链表 包含各种系统中的 USB 设备以及这些设备的所有接口，
		设备插入 USB 控制器之后，USB core 即会将设备在系统中注册，添加到 USB 设备链表上去
	USB驱动链表 包含 USB 设备驱动程序（usb device driver）和 USB 驱动程序（usb driver）。
		每个 USB 驱动程序的被注册时，USB 驱动程序即会添加到驱动链表上去

	
USB 驱动:
	我们常说的 USB 驱动, 指的是,在主机模式下,挂载在 USB 驱动链表里的一系列驱动,
	这些驱动因为主要工作是处理 urb ,
	通常只针对某个或几个特定接口interfaces工作,所以 USB 驱动 也可以叫是 usb设备的接口的驱动
	usb驱动工作:
		注册挂到 USB 驱动链表里,以日后参与匹配
		(当usb主机控制器 检测到 usb设备插入后,会提取信息并把设备挂到 usb 设备链表
		usb core 匹配 usb驱动 与 usb 设备,
		当设备商id与产品id匹配,表示匹配成功,然后执行 usb 驱动 probe 开始初始化设备 )
		初始化设备
		(根据用户的交互信息而选择特定配置和某几个特定接口,
		建立一个或多个/dev里的逻辑设备点,来映射具体接口或端点,
		为多个端点申请urb和初始化urb等等)
		处理操作
		(就是处理urb,使用urb访问usb设备具体功能的过程)
	用户访问usb设备的行为实际上就是:
		USB 驱动 往usb core 递交 urb ,
		usb core 递给 usb主机控制器, 
		usb主机控制器 与 usb设备 交互数据
		usb主机控制器 把交互结果,或者收到数据 通知或传递给 usb core
		usb core 表示这个 urb 递交成功,触发回调函数,并把这个urb还给 usb驱动

	
USB 过程:
	机器启动,
	注册 USB core 时，			，			添加到 linux 驱动链表上
	每个 USB 驱动程序的被注册时，					添加到   USB 驱动链表上	
	设备插入 USB 控制器之后，主机控制器枚举usb设备,提取usb设备的全部信息
	USB core 即会将设备在系统中注册，				添加到   USB 设备链表上
	usb core 尝试匹配设备与驱动,匹配成功,驱动执行 usb 驱动 的probe初始化,并最终把设备映射到 /dev/XX的一个逻辑设备文件上去
	probe初始化包括,选择配置,接口,初始接口等操作

urb:
	usb驱动,实际上通过给USBcore递交urb请求,请求受理并完成后调用回调处理函数的方式,
	实现了usb主机对从机设备的访问,控制,和传递数据的功能.

USB 鼠标例子
以下是一个usb鼠标驱动的例子,
	usb_mouse_init	应该是在 USB 驱动程序的被注册时 由USBcore调用的,
	插入usb鼠标后,
	probe程序	应该是在 USB 驱动程序 和 相应接口 进行配对 后由USBcore调用的,
			probe程序成功后,usb鼠标变可以工作,
			而且还会另外注册了一个linux输入(input)设备,把usb鼠标得到信息,源源不断写入输入设备文件

编译内核,支持u盘;(国嵌视频的内核版本)
make menucofig
Device Drivers  --->
	[*] USB support  --->
		<*>   Support for Host-side USB		(使能usb 主机端功能)
		<*>     OHCI HCD support		(usb主机控制器类型 ohci)
		<*>     USB Mass Storage support	(支持usb 储存设备)
General setup  --->
	[*] Configure standard kernel features (for small system)  --->
		[*]Support for hot-pluggable devices	(支持热插拔功能)
Device Drivers  --->
	[*] Block devices  --->
		<*> Low Perfermance USB Block driver	(u盘是块设备,支持usb通讯的块设备)
	SCSI device support  --->			(u盘,作为硬盘,又是符合SCSI标准的设备,所以使能相关标准)
		<*> SCSI device support
		<*> SCSI disk support
		<*> SCSI generic support
File systems  --->
	DOS/FAT/NT Filesystems  --->			(支持window相关的文件系统格式,因为fat一般是u盘的默认文件系统格式)
		<*> MSDOS fs support  
		<*> VFAT (Windows-95) fs support
		(936) Default codepage for FAT 
		(cp936) Default iocharset for FAT
	Partition Types --->				(支持硬盘设备的分区)
		[*] PC BIOS (MSDOS partition tables) support
	Native	Lahguage Support --->			(支持中文)
		<*> Simplified Chinese charset (CP936,GB2312)
		<*> NLS UTF8
编译后插入u盘 有反应,并自动在 /dev/下生成逻辑设备点文件 uda0
mount /dev/uda0  /mnt/	把uda0设备点文件映射挂载到mnt文件夹,这时,打开mmt文件夹,就相当于打开了u盘,
cd /mnt 相当于进入了u盘
ls 列出了u盘里的文件



开发板作为一个usb设备,插到pc机,被作为usb设备使用的例子:让usb模拟成以太网线 (国嵌教学内容)
make menucofig
Device Drivers  --->
	[*] USB support  --->
	<*>   USB Gadget Support  --->			(支持gadget)
		<*>   USB Gadget Support  --->
			USB Peripheral Controller (S3C2410 USB Device ) --->
				<*> S3C2410 USB device Controller	(打开UDC 驱动)
			<M>   USB Gadget Drivers
			<M>     Ethernet Gadget (with CDC Ethernet support)	(gadget API)
			[*]       RNDIS support (NEW)				(gadget Driver)

编译后,生成一个驱动模块 g_enter.ko 放入开发板,
开发板,insmod g_enter.ko后, 自身的usb模块就便成了一个usb设备,
严格说,只是开发板的USB模块变成了一个设备,这个设备是模拟成一个网络适配器,
当pc用usb连上开发板,就相当于 开发板与pc机都同时连上了一个网络适配器上,pc机与开发板是这个网络上的两个终端

pc机;	连上usb时,usb主机控制器会提取这个开发板上的usb设备的的所有信息,
	如果是windowpc,提示发现未知的 RNDIS_Gadget设备,
	pc要安装对应的驱动:设备管理器选择该设备->更新驱动软件->浏览计算机查找->从计算机列表选择->网络适配器->microsoft compasation
	->Remote NDIS Compatible device
	 成功后,在pc看来多了个网卡,设置pc在这网卡上的ip地址
开发板: ifconfig usb0 192.168.30.1 设置在这个网络上的ip地址
最后就能互相 ping 通

usb 驱动开发编写,很多时候是对urb的处理,通过内核的api获取usb的配置接口和端口信息,完成对urb的初始化.
国嵌只写了一个针对 usb线下载数据的 usb驱动作为参考





















