下载内核:
 wget https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.10.46.tar.xz 

该内核暂时,只面向uboot1!! 和 nfs:rootfs/rootfs1

/**************************** 最新状态 *********************************/
uboot1 nfs 启动内核:
uboot1:(nfs改到smart210/rootfs下) (pc的ip变了192.168.0.116)
set bootargs noinitrd root=/dev/nfs nfsroot=192.168.0.116:/home/kingders/smart210/rootfs/rootfs1 ip=192.168.0.200:192.168.0.116:192.168.0.1:255.255.255.0::eth0:off console=ttySAC0,115200n8 mem=64m
setenv bootmenu_0 "start0=tftp 20000000 uImage; bootm"
set serverip 192.168.0.116
set ipaddr 192.168.0.200
set machid 998 
saveenv

/**************************** command line *********************************/
linux不一定就要使用,uboot或者其他bootloader传递的 command line 参数 还可以用自身的宏定义默认的command line 参数
	方法一:做好编译配置后,修改 .config 的CONFIG_CMDLINE 再编译内核
	方法二:make menuconfig 里 按"/"然后搜索 CMDLINE 找出相关项进行配置,
如果设置成用自身的 commandline 则 uboot bootargs 写不写 也 也无所谓.




/**************************** 裁剪 *********************************/
arch/arm/只留下的mach-xx为mach-s5pv210,
且arch/arm/Kconfig留下:
# add by huang
source "arch/arm/plat-samsung/Kconfig"
source "arch/arm/mach-s5pv210/Kconfig"

/**************************** etc/fstab *********************************/
这个文件的全路径是/etc/fstab。它只是一个文本文件，你能够用你喜欢的编辑器打开它，
但是必须是root用户才能编辑它。同时fsck、mount、umount的等命令都利用该程序。
具体来说：用fstab可以自动挂载各种文件系统格式的硬盘、分区、可移动设备和远程设备等。
对于Windows与arch双操作系统用户，用fstab挂载FAT格式和NTFS格式的分区，可以在Linux中共享windows系统下的资源。



fstab文件示例
现在让我们看一下一个典型的fstab文件：

# <file system><dir><type><options><dump><pass>
none                   /dev/pts      devpts    defaults                0      0
none                   /dev/shm      tmpfs     defaults                0      0

/dev/cdrom             /media/cd     iso9660   ro,user,noauto,unhide   0      0
/dev/dvd               /media/dvd    udf       ro,user,noauto,unhide   0      0
/dev/fd0               /media/fl     auto      user,noauto             0      0

/dev/hda1              swap          swap      defaults                0      0
/dev/hda4              /             ext3      defaults                0      1
/dev/hda3              /home         xfs       rw,suid,exec,auto,nouser,async 0      2
</pass></dump></options></type></dir></file>

fstab详解
让我们对fstab的用法进行一个详细的了解。一个典型的entry有下面的fields (fields用空格或tab分开):
<file system><dir><type><options><dump><pass></pass></dump></options></type></dir></file>

	<file systems> 不是我们通常理解的文件系统，而是指设备（硬盘及其分区，DVD光驱等）。它告知我们设备（分区）的名字，
	这是你在命令行中挂载（mount）、卸载（umount）设备时要用到的。
	so one should substitute for this entry the device name, remote partition, or similar. </file>
	注意: 除了直接用设备（分区）名字，你也可以用UUID或卷名。格式 LABEL= or UUID=<uuid>。
	例如, `LABEL=Boot' or `UUID=3e6be9de-8139-11d1-9106-a43f08d823a6'. </uuid>

	<dir>告诉我们设备挂载到哪里。

	<type> 指挂载设备或分区为何种文件系统类型（例如：ext2, ext3, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap等）。 
	archLinux支持许多文件系统。 要得到一个完整的支持名单查找mount man-page。
	典型 的名字包括这些：ext2, ext3, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, 
	swap和auto, 'auto' 不是一个文件系统，而是让mount命令自动判断文件类型，
	特别对于可移动设备，软盘，DVD驱动器，这样做是很有必要的，因为可能每次挂载的文件类型不一致。 </type>

	<options>，选项，这部分是最有用的设置！！！ </options>
	它能使你所挂载的设备在开机时自动加载、使中文显示不出现乱码、限制对挂载分区读写权限。
	它是与mount命令的用法相关的，要想得到一个完整的列表，参考mount manpage.
	noatime   关闭atime特性，提高性能，这是一个很老的特性，放心关闭，还能减少loadcycle
	defaults  使用默认设置。等于rw,suid,dev,exec,auto,nouser,async，具体含义看下面的解释。
	auto  在启动或在终端中输入mount -a时自动挂载
	noauto  设备（分区）只能手动挂载 The file system can be mounted only explicitly.
	iocharset＝   在＝号后面加入你的本地编码，似乎在这个设备（分区）中做文件IO的时候就会自动做编码的格式转换。
   		例如：你的某个分区是编码是utf8，而设备中文件的编码是gb2312，当是复制你设备中的文件到你的这个分区时，它将自动做编码转换。  
	nls=     在=号后面加入你的本地编码，你的中文就不会出现乱码。
	umask=   这是关于读写权限的，好像比下面的ro，rw选项更管用！！！
		例如：umask=000或0222，使得挂载时option中有default，普通用户仍然能读写挂载设备中的东西。
		ro  挂载为只读权限
		rw   挂载为读写权限
	exec     是一个默认设置项，它使在那个分区中的可执行的二进制文件能够执行。
	noexec  二进制文件不允许执行。千万不要在你的root分区中用这个选项！！！
	user  允许任何用户挂载设备。 Implies noexec,nosuid,nodev unless overridden.
	nouser  只允许root用户挂载。这是默认设置。
	suid    Permit the operation of suid, and sgid bits. They are mostly used to allow users on a computer system 
		to execute binary executables with temporarily elevated privileges in order to perform a specific task.
   	nosuid   Blocks the operation of suid, and sgid bits.

	<dump> 是dump utility用来决定是否做备份的. 安装之后(Arch Linux默认是不安装dump的), 
	dump会检查entry并用数字来决定是否对这个文件系统进行备份。允许的数字是0和1。
	如果是0，dump就会忽略这个文件系统，如果是1，dump就会作一个备份。
	大部分的用户是没有安装dump的，所以对他们而言<dump>这个entry应该写为0。 </dump></dump>

	<pass> fsck会检查这个头目下的数字来决定检查文件系统的顺序
	（looks at the number substituted for <pass> and determines in which order the file systems should be checked）。
	允许的数字是0, 1, 和2。 文件系统的<pass>选项是0将不会被fsck utility检查。
	root文件系统应该拥有最高的优先权 1，
	而所有其它的文件系统，如果你想让它被check的话，应该写成2。 </pass></pass></pass>



用fstab自动挂载FAT32和NTFS分区
1.先在用fdisk -l（可能需要在root权限下）得到硬盘信息表，例如：
＃  Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1        2397    19253871    b  W95 FAT32
/dev/sda2            2398        3144     6000277+  83  Linux
/dev/sda3            3145        9729    52894012+   5  Extended
/dev/sda5            3145        3152       64228+  83  Linux
/dev/sda6            3153        3276      995998+  82  Linux swap / Solaris
/dev/sda7            3277        7340    32644048+  83  Linux
/dev/sda8            7341        9729    19189611    7  HPFS/NTFS

从上面知道，这台电脑上只有一个硬盘，其中分区sda1和sda8为NTFS格式，sda1为可以启动的，因而可能为window的系统所在盘。
下面把系统盘以只读方式持载上去，非系统盘sda8以读写方式挂载上去（不能挂载在"/"及其以下的任何目录）。

2.用你喜欢的编辑器在终端中打开/etc/fstab，例如：nano /etc/fstab
在文件末尾加入：
/dev/sda1 /mnt/WindowsC vfat defaults,codepage=936,iocharset=cp936,umask=0222 0 0
/dev/sda8 /mnt/WindowsD ntfs defaults,iocharset=utf8,umask=000,nls=utf8 0 0
保存，退出。
警告：使用936的codepage挂在fat32分区可能会造成linux下识别中文正常但是到windows下反而出现乱码，
推荐替换成utf8，但是dmesg提示警告，没有关系，n多人用了这么长时间都没有问题
/dev/sda1 /mnt/WindowsC vfat user,utf8,umask=000 0 0

3.在终端中输入
mount -a
你就应该能在/mnt/WindowsC下找到你的系统分区sda1内容，在/home/username/WindowsD中找到sda8的内容(其中username指用户名)



samrt210的nfs文件系统的fstab
#device   mount-point   type     options        dump  fsck order
proc      /proc         proc     defaults     	0     0
tmpfs     /tmp         	tmpfs    defaults       0     0
sysfs     /sys          sysfs    defaults       0     0
tmpfs     /dev          tmpfs    defaults       0     0


/**************************** 内核初启动,注意最后卡死在文件系统初始化失败 *********************************/

修改主Makefile:		//非常重要,确保后面的配置操作时(包括make menuconfig),配置系统只调出 arm 架构的配置选项,而非其他内容
#add by huang
ARCH		?= arm
CROSS_COMPILE	?= arm-linux-


配置操作:
make s5pv210_defconfig 		//初步配置
make menuconfig			//具体调整
	System Type--->
		(0) S3C UART to use for low-level messages	//串口0做调试输出
		S5PV210 Machines--->
			[*] SMDKV210	//只选择SMDKV210这个板子,其他Machines,包括S5PC110的Machines全部取消选择


编译调试:
make uImage -j4
"mkimage" command not found - U-Boot images will not be built
make[1]: *** [arch/arm/boot/uImage] Error 1	
这里的mkimage工具是另外uboot提供的,
解决:sudo apt-get install u-boot-tools
重新make uImage -j4 成功

由于使用 tftp 拷贝 uImage,所以修改Makefile,编译完自动拷贝文件到tftpboot
arch/arm/boot/Makefile:
$(obj)/uImage:	$(obj)/zImage FORCE
	@$(check_for_multiple_loadaddr)
	$(call if_changed,uimage)
	@$(kecho) '  Image $@ is ready'
	cp $(obj)/uImage /tftpboot/		//编译完自动拷贝文件到tftpboot

开发板操作:
tftp 20000000 uImage		//拷入uImage到ram 0x20000000
bootm				//启动内核
tftpboot 20000000 uImage;bootm



开发板操作log:
启动内核后:
Error: unrecognized/unsupported machine ID (r1 = 0x00000722).
由于,uboot的全局变量的机器码id与kernel全局变量的机器码id不一致,内核的 SMDKV210 开发板的机器码 2456(0x998)
所以修改uboot4:
uboot4/u-boot-2014.04/arch/arm/include/asm/mach-types.h
	#define MACH_TYPE_SMDKV210             2456
	/* add by huang */
	#define MACH_TYPE_SMART210             2456
uboot4/u-boot-2014.04/board/samsung/smart210/smart210.c
	int board_init(void)
	{
		dm9000_pre_init();	/* 为dm9000 设置SROM,bank1相关寄存器bw,bc */
		gd->bd->bi_arch_number = MACH_TYPE_SMART210;
		gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
		return 0;
	}

修改后重试:
VFS: Cannot open root device "mtdblock5" or unknown-block(0,0): error -6
Please append a correct "root=" boot option; here are the available partitions:
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
CPU: 0 PID: 1 Comm: swapper Not tainted 3.10.102 #1
处理make menuconfig 把filesystem全部取消勾选重试:
VFP support v0.3: implementor 41 architecture 3 part 30 variant c rev 2
VFS: Cannot open root device "mtdblock5" or unknown-block(0,0): error -19
Please append a correct "root=" boot option; here are the available partitions:
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
CPU: 0 PID: 1 Comm: swapper Not tainted 3.10.102 #2
处理make menuconfig 勾选device drivers -> 
				Memory Technology Device (MTD) support --->
					Caching block device access to MTD devices
重试:
VFP support v0.3: implementor 41 architecture 3 part 30 variant c rev 2
VFS: Cannot open root device "mtdblock5" or unknown-block(0,0): error -19
Please append a correct "root=" boot option; here are the available partitions:
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
CPU: 0 PID: 1 Comm: swapper Not tainted 3.10.102 #3
注意:文件系统仍然没有处理好,在这种情况下,直接下一步,初始话dm9000


/**************************** 初始化dm9000 与nfs 成功 *********************************/

arch/arm/mach-s5pv210/include/mach/map.h
/* add by huang  */
#define S5PV210_PA_SROM_BANK1		0x88000000	//因为dm9000接在srom bank1

arch/arm/mach-s5pv210/mach-smdkv210.c
/* add by huang */
static struct resource smdkv210_dm9000_resources[] = {
	[0] = DEFINE_RES_MEM(S5PV210_PA_SROM_BANK1, 4),
	[1] = DEFINE_RES_MEM(S5PV210_PA_SROM_BANK1 + 4, 4),
	[2] = DEFINE_RES_NAMED(IRQ_EINT(7), 1, NULL, IORESOURCE_IRQ \		//smart210 开发板的 DM9000 使用外部中断 7
				| IORESOURCE_IRQ_HIGHLEVEL),
};
static void __init smdkv210_machine_init(void)
{
	s3c_pm_init();
	/* add by huang */
	/* smdkv210_dm9000_init(); */		//由于uboot已经初始化dm9000,这里先注释掉
....}

make menuconfig:
[*] Networking support --->
	Networking options --->
		<*> Packet socket
		<*>	Packet: sockets monitoring interface
		<*> Unix domain sockets
		<*>	UNIX: socket monitoring interface
		[*] TCP/IP networking
		[*]	IP: multicasting
		[*]	IP: advanced router
		[*] 	IP: kernel level autoconfiguration
		[*] 		IP: DHCP support
		[*] 		IP: BOOTP support
		[*] 		IP: RARP support
Device Drivers --->
	[*] Network device support --->
		[*]Ethernet driver support (NEW) --->
			<*> DM9000 support		//将其他的设备全部去掉,只保留 DM9000
File systems--->
	[*] Network File Systems (NEW) --->
		<*> NFS client support 
		[*] Root file system on NFS

制作一个根文件系统:
下载busybox-1.21.1: https://busybox.net/downloads/
解压,并cd到busybox-1.21.1配置:make menuconfig
Busybox Settings --->
	General Configuration --->
		[ ] Enable options for full-blown desktop systems //我们使用的是嵌入式系统,如果不取消,在执行 ps 命令时不会显示进程状态
	Build Options --->
		[*] Build BusyBox as a static binary (no shared libs) 	//一定要静态编译,不然启动内核时会说找不到init
									//因为拷贝的_intall里的内容都只是链接文件,
									//如果没有库文件在就会显示链接失败
		(arm-linux-) Cross Compiler prefix	//指定交叉编译器前缀
	Installation Options ("make install" behavior) --->
		(./_install) BusyBox installation prefix (NEW)	//指定安装路径(即busybox-1.21.1/_install)
Init Utilities --->
	[ ] Be _extra_ quiet on boot	//取消可以在系统启动时显示 busybox 版本号加载和卸载内核模块
Linux Module Utilities --->
	[ ] Simplified modutils		//我们不适应简单的,我们需要使用 insmod 等工具
	[*] insmod
	[*] rmmod
	[*] lsmod
	[*] modprobe
	[*] depmod
编译和安装:
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/busybox/busybox-1.21.1$ make && make install
建立rootfs:
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/busybox/busybox-1.21.1$ mkdir ../../rootfs
拷贝生成内容到rootfs:
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/busybox/busybox-1.21.1$ cp _install/* ../../rootfs/ -a   //这里的"*/"与指令无关
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/busybox/busybox-1.21.1$ cp examples/bootfloppy/etc/ ../../rootfs/ -r
拷贝系统的 passwd、group、shadow 到根文件系统
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ cp /etc/passwd etc/
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ cp /etc/group etc/
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ sudo cp /etc/shadow etc/
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ sudo chmod 777 etc/shadow //以防万一,给烤来的shadow解权限
改password文件:
rootfs/etc/password:
root:x:0:0:root:/root:/bin/ash	//因为文件系统的 bin 目录下没有 bash 这个命令,而是用 ash 代替 bash
创建必要的设备文件节点:
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ mkdir dev
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ sudo mknod dev/console c 5 1	
	//console是设备的名字
	//c指字符设备
	//5是该设备在major.h中定义的标记
	//1是第一个子设备
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ sudo mknod dev/null c 1 3
创建相关目录:
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ mkdir mnt proc var tmp sys root lib
从交叉编译器拷贝库到 rootfs 的 lib 目录:
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ cp /opt/FriendlyARM/toolschain/4.5.1/arm-none-linux-gnueabi/sys-root/usr/lib/* lib/ -a			//这里的"*/"与指令无关
压缩目录:
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ su
root@kingders-ThinkPad-T420:/home/kingders/smart210/kernel/kernel2/rootfs# arm-linux-strip lib/*		//这里的"*/"与指令无关
以下:参考见210嵌入笔记kernel:6.2的例子
	修改 rootfs/etc/inittab: 
# /etc/inittab
# This is run first except when booting in single-user mode.
::sysinit:/etc/init.d/rcS
# Note below that we prefix the shell commands with a "-" to indicate to the
# shell that it is supposed to be a login shell
# Start an "askfirst" shell on the console (whatever that may be)
::askfirst:-/bin/sh
# Start an "askfirst" shell on /dev/tty2
#tty2::askfirst:-/bin/sh
# Stuff to do before rebooting
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a –r	
	修改 rootfs/ etc/fstab 	
#device	mount-point	type	options		dump	fsck order
proc	/proc		proc	defaults	0	0
tmpfs	/tmp		tmpfs	defaults	0	0
sysfs	/sys		sysfs	defaults	0	0
tmpfs	/dev		tmpfs	defaults	0	0
	修改 rootfs/etc/init.d/rcS
#!/bin/sh
#This is the first script called by init process
mount -a
mkdir /dev/pts
mount -t devpts devpts /dev/pts
echo /sbin/mdev>/proc/sys/kernel/hotplug
mdev –s
	修改 rootfs/etc/profile		//关于这几个文件的内容一定要网上research
#!/bin/sh
`hostname huang`
HOSTNAME=`hostname`
USER=`id -un`
LOGNAME=$USER
HOME=$USER
PS1="[\u@$\h: \W]\# "
PATH=/bin:/sbin:/usr/bin:/usr/sbin
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
alias ll="ls -l"
echo "Processing /etc/profile... "
echo "Done"

开启pc的nfs服务:
apt-get install nfs-kernel-server	//安装nfs服务器
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/rootfs$ sudo gedit /etc/exports	//修改exports
/home/kingders/smart210/kernel/kernel2/rootfs  *(rw,sync,no_subtree_check,no_root_squash)	//添加内容
	/home/jacobxu/nfs-jacoxu：与nfs服务客户端共享的目录，这个路径必须和你前面设置的文件的路径一致！
	*：允许所有的网段访问，也可以使用具体的IP
	rw：挂接此目录的客户端对该共享目录具有读写权限
	sync：资料同步写入内存和硬盘
	no_root_squash：root用户具有对根目录的完全管理访问权限。
	no_subtree_check：不检查父目录的权限。
执行命令：sudo /etc/init.d/rpcbind restart 重启rpcbind 服务。nfs是一个RPC程序，使用它前，需要映射好端口，通过rpcbind 设定。
执行命令：sudo /etc/init.d/nfs-kernel-server restart 重启nfs服务

运行(成功):
使用已完备移植的uboot4:
sd卡启动
设置bootargs:
set bootargs root=/dev/nfs nfsroot=192.168.2.227:/home/kingders/smart210/kernel/kernel2/rootfs ip=192.168.2.120:192.168.2.227:192.168.2.1:255.255.255.0 console=ttySAC0,115200n8 mem=64m
	//root=/dev/nfs		根文件设备挂载的设备点，这里是nfs文件系统
	//nfsroot=192.168.2.227:/home/kingders/smart210/kernel/kernel2/rootfs	nfs文件系统映射到的目录
	//ip=192.168.2.120:192.168.2.227:192.168.2.1:255.255.255.0	板子ip:nfs服务器ip:网关ip:子网掩码
	//console=ttySAC0,115200n8	console终端的挂载的串口设备点ttySAC0，波特率115200,no parity,数据８位传输	
	//mem=64m	这里是nfs文件系统运行时,被分配的ram的缓存大小
	//		因为面向这个linux内核版本,这个参数不能不设,不然会卡死在Uncompressing Linux... done, booting the kernel.
	//		而且也不能设太大,不然系统会跑偏,关于内核的内存布局值得另外深入研究.
	//经过复杂调试,以上的bootargs才能使内核稳定启动.
保存环境变量:
saveenv
tftp下载并启动:		
tftpboot 20000000 uImage;bootm		//用";"隔开,可以一次输入多指令
尝试简单命令:
ps cd top....

另外:启动中
dm9000 dm9000: read wrong id 0x01010101
这是 dm9000 驱动在读取 ID 时的错误,驱动中会连续读取 8 次,这里第一次读取错误,我们可以在
第一次读取之前加上一个延时,就可以解决这个错误。在移植 u-boot 中就加了一个延时
然而设置了while(100--)还是没有用,难道要相当大的延时?不管,反正无影响.

bootargs=root=/dev/nfs nfsroot=192.168.2.227:/home/kingders/smart210/rootfs/rootfs1 ip=192.168.2.120:192.168.2.227:192.168.2.1:255.255.255.0 init=/linuxrc console=ttySAC0,115200n8 mem=32m


/**************************** nand移植 成功 *********************************/

并没有关于s5p架构的nand控制器架构,但是这款芯片继承s3c架构的nand控制器架构,所以可以移植s3c_nand架构内容驱动nand控制器

arch/arm/plat-samsung/include/plat/regs-nand.h
/* add by huang */
#define S5PV210_NFCONF  		S3C2410_NFREG(0x00)
#define S5PV210_NFCONT  		S3C2410_NFREG(0x04)
#define S5PV210_NFCMD   		S3C2410_NFREG(0x08)
#define S5PV210_NFADDR  		S3C2410_NFREG(0x0C)
#define S5PV210_NFDATA  		S3C2410_NFREG(0x10)
#define S5PV210_NFSTAT  		S3C2410_NFREG(0x28)
/* about nand flash ecc */
#define S5PV210_NFECC			S3C2410_NFREG(0x20000)
#define S5PV210_NFECCCONF  		S3C2410_NFREG(0x00) + (S5PV210_NFECC)
#define S5PV210_NFECCCONT  		S3C2410_NFREG(0x20) + (S5PV210_NFECC)
#define S5PV210_NFECCSTAT		S3C2410_NFREG(0x30) + (S5PV210_NFECC)
#define S5PV210_NFECCSECSTAT	S3C2410_NFREG(0x40) + (S5PV210_NFECC)
#define S5PV210_NFECCPRGECC0	S3C2410_NFREG(0x90) + (S5PV210_NFECC)
#define S5PV210_NFECCPRGECC1	S3C2410_NFREG(0x94) + (S5PV210_NFECC)
#define S5PV210_NFECCPRGECC2	S3C2410_NFREG(0x98) + (S5PV210_NFECC)
#define S5PV210_NFECCPRGECC3	S3C2410_NFREG(0x9C) + (S5PV210_NFECC)
#define S5PV210_NFECCERL0		S3C2410_NFREG(0xC0) + (S5PV210_NFECC)
#define S5PV210_NFECCERL1		S3C2410_NFREG(0xC4) + (S5PV210_NFECC)
#define S5PV210_NFECCERL2		S3C2410_NFREG(0xC8) + (S5PV210_NFECC)
#define S5PV210_NFECCERL3		S3C2410_NFREG(0xCC) + (S5PV210_NFECC)
#define S5PV210_NFECCERP0		S3C2410_NFREG(0xF0) + (S5PV210_NFECC)
#define S5PV210_NFECCERP1		S3C2410_NFREG(0xF4) + (S5PV210_NFECC)

drivers/mtd/nand/Kconfig
config MTD_NAND_S3C2410
	tristate "NAND Flash support for Samsung S3C SoCs"
	depends on ARCH_S3C24XX || ARCH_S3C64XX || ARCH_S5PV210		//让 drivers/mtd/nand/s3c2410.c 被编译进内核
	help								//如果不添加 ARCH_S5PV210,配置菜单不会出现这个选项
	  This enables the NAND flash controller on the S3C24xx and S3C64xx
	  SoCs
	  No board specific support is done by this driver, each board
	  must advertise a platform_device for the driver to attach.

drivers/mtd/nand/s3c2410.c
enum s3c_cpu_type {
	TYPE_S3C2410,
	TYPE_S3C2412,
	TYPE_S3C2440,
	/* add by zjh */
	TYPE_S5PV210,		};
static int s3c2410_nand_setrate(struct s3c2410_nand_info *info)
{....
	switch (info->cpu_type) {.....			//设置分频
	/* add by huang */
	case TYPE_S5PV210:
		mask = (0xF << 12) | (0xF << 8) | (0xF << 4);

		set = (tacls + 1) << 12;
		set |= (twrph0 - 1 + 1) << 8;
		set |= (twrph1 - 1 + 1) << 4;
		break;		...}.....}
static int s3c24xx_nand_probe(struct platform_device *pdev)
{......
	info->clk = devm_clk_get(&pdev->dev, "nand");	//获得 nand 控制器时钟
......}
static int s3c2410_nand_inithw(struct s3c2410_nand_info *info)
{
	int ret;
	unsigned long uninitialized_var(cfg);	/* add by zjh */
	
	ret = s3c2410_nand_setrate(info);
	if (ret < 0)
		return ret;
	switch (info->cpu_type) {
	case TYPE_S3C2410:
	default:
		break;
	case TYPE_S3C2440:
	case TYPE_S3C2412:
		/* enable the controller and de-assert nFCE */
		writel(S3C2440_NFCONT_ENABLE, info->regs + S3C2440_NFCONT);
		break;	/* add by zjh */		
	/* add by zjh */
	case TYPE_S5PV210:
		cfg = readl(info->regs + S5PV210_NFCONF);
		cfg &= ~(0x1 << 3);	/* SLC NAND Flash */
		cfg &= ~(0x1 << 2);	/* 2KBytes/Page */
		cfg |= (0x1 << 1);	/* 5 address cycle */
		writel(cfg, info->regs + S5PV210_NFCONF);
		/* Disable chip select and Enable NAND Flash Controller */
		writel((0x1 << 1) | (0x1 << 0), info->regs + S5PV210_NFCONT);
		break;
	}
	return 0;
}
/* add by huang */
static void s5pv210_nand_hwcontrol(struct mtd_info *mtd, int cmd,
				   unsigned int ctrl)
{
	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
	if (cmd == NAND_CMD_NONE)
		return;
	if (ctrl & NAND_CLE)
		writeb(cmd, info->regs + S5PV210_NFCMD);
	else
		writeb(cmd, info->regs + S5PV210_NFADDR);
}
/* add by huang */
static int s5pv210_nand_devready(struct mtd_info *mtd)
{
	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
	return readb(info->regs + S5PV210_NFSTAT) & 0x1;
}
static void s3c2410_nand_init_chip(struct s3c2410_nand_info *info, struct s3c2410_nand_mtd *nmtd, struct s3c2410_nand_set *set)
{........
	switch (info->cpu_type) {.......
	/* add by huang */
	case TYPE_S5PV210:
		chip->IO_ADDR_W = regs + S5PV210_NFDATA;
		info->sel_reg   = regs + S5PV210_NFCONT;
		info->sel_bit	= (1 << 1);
		chip->cmd_ctrl  = s5pv210_nand_hwcontrol;
		chip->dev_ready = s5pv210_nand_devready;
		break;
	}
......)
static struct platform_device_id s3c24xx_driver_ids[] = {
	{
		.name		= "s3c2410-nand",
		.driver_data	= TYPE_S3C2410,
	}, {
		.name		= "s3c2440-nand",
		.driver_data	= TYPE_S3C2440,
	}, {
		.name		= "s3c2412-nand",
		.driver_data	= TYPE_S3C2412,
	}, {
		.name		= "s3c6400-nand",
		.driver_data	= TYPE_S3C2412, /* compatible with 2412 */
	},{	/* add by hunag */
		.name		= "s5pv210-nand",
		.driver_data	= TYPE_S5PV210,
	},
	{ }
};


arch/arm/mach-s5pv210/clock.c
static struct clk init_clocks_off[] = {....
	{	/* add by huang */
		.name		= "nand",		//添加 针对 nand 定义时钟
		.parent		= &clk_hclk_psys.clk,
		.enable		= s5pv210_clk_ip1_ctrl,
		.ctrlbit	= (1 << 24),
	},		
.....};

arch/arm/plat-samsung/devs.c
#ifdef CONFIG_S3C_DEV_NAND			//nand控制器是一个平台设备,根据宏,选择是否加入nand控制器平台设备到内核
static struct resource s3c_nand_resource[] = {
	[0] = DEFINE_RES_MEM(S3C_PA_NAND, SZ_1M),
};

struct platform_device s3c_device_nand = {
	.name		= "s3c2410-nand",
	.id		= -1,
	.num_resources	= ARRAY_SIZE(s3c_nand_resource),
	.resource	= s3c_nand_resource,
};.......

arch/arm/mach-s5pv210/Kconfig
config MACH_SMDKV210
	bool "SMDKV210"
	select CPU_S5PV210
	select S3C_DEV_FB
	select S3C_DEV_HSMMC
	select S3C_DEV_HSMMC1
	select S3C_DEV_HSMMC2
	select S3C_DEV_HSMMC3
	select S3C_DEV_I2C1
	select S3C_DEV_I2C2
	select S3C_DEV_RTC
	select S3C_DEV_USB_HSOTG
	select S3C_DEV_WDT
	select S5PV210_SETUP_FB_24BPP
	select S5PV210_SETUP_I2C1
	select S5PV210_SETUP_I2C2
	select S5PV210_SETUP_IDE
	select S5PV210_SETUP_KEYPAD
	select S5PV210_SETUP_SDHCI
	select S5PV210_SETUP_USB_PHY
	select S5P_DEV_FIMC0
	select S5P_DEV_FIMC1
	select S5P_DEV_FIMC2
	select S5P_DEV_JPEG
	select S5P_DEV_MFC
	select SAMSUNG_DEV_ADC
	select SAMSUNG_DEV_BACKLIGHT
	select SAMSUNG_DEV_IDE
	select SAMSUNG_DEV_KEYPAD
	select SAMSUNG_DEV_PWM
	select SAMSUNG_DEV_TS
	select S3C_DEV_NAND		//添加,表示 #define CONFIG_S3C_DEV_NAND ,表示加入nand控制器平台设备到内核
	help
	  Machine support for Samsung SMDKV210

arch/arm/mach-s5pv210/include/mach/map.h
/* add by huang  */
#define S5PV210_PA_NAND			0xB0E00000	
#define S3C_PA_NAND			S5PV210_PA_NAND	//nand控制器平台设备的基地址,设备初始化等情况下要使用到

arch/arm/mach-s5pv210/mach-smdkv210.c
/* add by huang */
#include <plat/nand-core.h>
#include <linux/platform_data/mtd-nand-s3c2410.h>
#include <linux/mtd/partitions.h>
/* nand info start (add by zjh) */
static struct mtd_partition smdk_default_nand_part[] = {	//nandflash的分区信息,要求与uboot的一致
	[0] = {							//由于此刻的uboot的nandflash的分区与此不一致,缺少log区
		.name	= "bootloader",				//所以uboot的重新分区
		.size	= SZ_256K,
		.offset	= 0,
	},
	[1] = {
		.name	= "params",
		.offset = MTDPART_OFS_APPEND,
		.size	= SZ_128K,
	},
	[2] = {
		.name	= "log",
		.offset = MTDPART_OFS_APPEND,
		.size	= SZ_2M,
	},
	[3] = {
		.name	= "kernel",
		.offset	= MTDPART_OFS_APPEND,
		.size	= SZ_1M + SZ_2M,
	},

	[4] = {
		.name	= "rootfs",
		.offset = MTDPART_OFS_APPEND,
		.size	= MTDPART_SIZ_FULL,
	}
};

static struct s3c2410_nand_set smdk_nand_sets[] = {
	[0] = {
		.name		= "NAND",
		.nr_chips	= 1,
		.nr_partitions	= ARRAY_SIZE(smdk_default_nand_part),
		.partitions	= smdk_default_nand_part,
		.disable_ecc = 1,
	},
};

static struct s3c2410_platform_nand smdk_nand_info = {
	.tacls		= 12,
	.twrph0		= 12,
	.twrph1		= 5,
	.nr_sets	= ARRAY_SIZE(smdk_nand_sets),
	.sets		= smdk_nand_sets,
};

static void s5pv210_nand_gpio_cfg(void)
{
	volatile unsigned long *mp01;
	volatile unsigned long *mp03;
	volatile unsigned long *mp06;	
	mp01 = (volatile unsigned long *)ioremap(0xE02002E0, 4);
	mp03 = (volatile unsigned long *)ioremap(0xE0200320, 4);
	mp06 = (volatile unsigned long *)ioremap(0xE0200380, 4);	
	*mp01 &= ~(0xFFFF << 8);
	*mp01 |= (0x3333 << 8);
	*mp03 = 0x22222222;
	*mp06 = 0x22222222;	
	iounmap(mp01);
	iounmap(mp03);
	iounmap(mp06);
}
/* nand info end (add by zjh) */
static struct platform_device *smdkv210_devices[] __initdata = {
	&s3c_device_adc,
	&s3c_device_cfcon,
	&s3c_device_fb,
	&s3c_device_hsmmc0,
	&s3c_device_hsmmc1,
	&s3c_device_hsmmc2,
	&s3c_device_hsmmc3,
	&s3c_device_i2c0,
	&s3c_device_i2c1,
	&s3c_device_i2c2,
	&s3c_device_rtc,
	&s3c_device_ts,
	&s3c_device_usb_hsotg,
	&s3c_device_wdt,
	&s5p_device_fimc0,
	&s5p_device_fimc1,
	&s5p_device_fimc2,
	&s5p_device_fimc_md,
	&s5p_device_jpeg,
	&s5p_device_mfc,
	&s5p_device_mfc_l,
	&s5p_device_mfc_r,
	&s5pv210_device_ac97,
	&s5pv210_device_iis0,
	&s5pv210_device_spdif,
	&samsung_asoc_idma,
	&samsung_device_keypad,
	&smdkv210_dm9000,
	&smdkv210_lcd_lte480wv,
	&s3c_device_nand,	/* add by huang */
};
static void __init smdkv210_machine_init(void)
{
	s3c_pm_init();
	/* masked by zjh */
	//smdkv210_dm9000_init();	
	/* add by zjh */
	s3c_nand_setname("s5pv210-nand");		//nand 设名 为了 arch/arm/plat-samsung/devs.c:s3c_device_nand
	s3c_nand_set_platdata(&smdk_nand_info);		//nand 设置平台设备信息
	s5pv210_nand_gpio_cfg();			//设置 nand gpio
	samsung_keypad_set_platdata(&smdkv210_keypad_data);
	s3c24xx_ts_set_platdata(NULL);
	s3c_i2c0_set_platdata(NULL);
	s3c_i2c1_set_platdata(NULL);
	s3c_i2c2_set_platdata(NULL);
	i2c_register_board_info(0, smdkv210_i2c_devs0,
			ARRAY_SIZE(smdkv210_i2c_devs0));
	i2c_register_board_info(1, smdkv210_i2c_devs1,
			ARRAY_SIZE(smdkv210_i2c_devs1));
	i2c_register_board_info(2, smdkv210_i2c_devs2,
			ARRAY_SIZE(smdkv210_i2c_devs2));
	s3c_ide_set_platdata(&smdkv210_ide_pdata);
	s3c_fb_set_platdata(&smdkv210_lcd0_pdata);
	samsung_bl_set(&smdkv210_bl_gpio_info, &smdkv210_bl_data);
	s3c_hsotg_set_platdata(&smdkv210_hsotg_pdata);
	platform_add_devices(smdkv210_devices, ARRAY_SIZE(smdkv210_devices));
}

make menuconfig
Device Drivers --->
	<*> Memory Technology Device (MTD) support --->
		<*> Caching block device access to MTD devices 
		<*> NAND Device Support --->
			<*> NAND Flash support for Samsung S3C SoCs
make uImage -j4

运行:
使用已完备移植的uboot4:
sd卡启动 (仍然过载nfs启动)
tftp下载并启动:		
tftpboot 20000000 uImage;bootm
启动log已经可以看到初始化nand的内容:
brd: module loaded
loop: module loaded
s3c24xx-nand s5pv210-nand: Tacls=2, 14ns Twrph0=2 14ns, Twrph1=1 7ns
s3c24xx-nand s5pv210-nand: NAND ECC disabled
NAND device: Manufacturer ID: 0xec, Chip ID: 0xdc (Samsung NAND 512MiB 3,3V 8-bit), 512MiB, page size: 2048, OOB size: 64
NAND_ECC_NONE selected by board driver. This is not recommended!
Scanning device for bad blocks
Creating 5 MTD partitions on "NAND":
0x000000000000-0x000000040000 : "bootloader"
0x000000040000-0x000000060000 : "params"
0x000000060000-0x000000260000 : "log"
0x000000260000-0x000000560000 : "kernel"
0x000000560000-0x000020000000 : "rootfs"

/**************************** nand 挂载jffs2文件系统  *********************************/

制作jffs2文件系统:
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2/linux-3.10.102$ sudo apt-get install mtd-utils
然后便可以使用 mkfs.jffs2 制作 jffs2 文件系统了:
kingders@kingders-ThinkPad-T420:~/smart210/kernel/kernel2$ sudo mkfs.jffs2 -d rootfs -o rootfs.jffs2 -s 2048 -e 0x20000 –n
	//-d:指定根文件系统目录
	//-o:指定输出文件
	//-s:指定页大小 2K(根据 NAND FLASH 芯片手册)
	//-e:指定块擦除大小 128K, 所以 -e 0x20000 (根据 NAND FLASH 芯片手册)
	//-n:指定不要在每个擦除块上添加清除标记
uboot操作:
SMART210 # nand erase.part rootfs
SMART210 # tftp 20000000 rootfs.jffs2
SMART210 # nand write 20000000 rootfs $filesize  //注意: 不可以 $(filesize)
SMART210 # set bootargs root=/dev/mtdblock4 rootfstype=jffs2 init=/linuxrc console=ttySAC0,115200n8 mem=64m
SMART210 # saveenv
修改内核配置支持jffs2文件系统:
make menuconfig
File systems --->
	[*] Miscellaneous filesystems --->
		<*> Journalling Flash File System v2 (JFFS2) support
make uImage -j4

调试:
tftp下载并启动:		
tftpboot 20000000 uImage;bootm
log:
VFS: Mounted root (jffs2 filesystem) on device 31:4.
Freeing unused kernel memory: 136K (80376000 - 80398000)
Failed to execute /linuxrc.  Attempting defaults...
Kernel panic - not syncing: 	No init found.  Try passing init= option to kernel. See Linux Documentation/init.txt for guidance.
CPU: 0 PID: 1 Comm: swapper Not tainted 3.10.102 #7
问题在于,找不到/linuxrc,然而/linuxrc是存在的,那么最有可能是放错位置,然而,rootfs.jffs2的确是烧在rootfs分区的,
那么有可能uboot的分区与内核的分区地址不一致,
检查uboot分区:mtdparts
发现原来的确是分区错了,缺少log区,使uboot与内核的rootfs地址起始处相对错位!!
即uboot拷到uboot的rootfs时,实际上,在内核看来是log区的地方!!
uboot重置分区,并且最后一定要saveenv保存环境变量!!!这次错误是之前uboot重置分区后,没有saveenv,导致后面重新上电后,打回原形
修改后重试成功.

最后:
set bootargs root=/dev/mtdblock4 rootfstype=jffs2 init=/linuxrc console=ttySAC0,115200n8 mem=64m 
//uboot设bootargs时,一定要设置mem,不然一定出错!!

整合一些常用命令:
nandflash擦除 rootfs 块, 然后tftp下载 rootfs.jffs2文件系统设备的文件,然后写入 rootfs 块始地址
nand erase.part rootfs;tftp 20000000 rootfs.jffs2;nand write 20000000 rootfs $filesize

设置nfs文件系统启动参数
set bootargs root=/dev/nfs nfsroot=192.168.2.227:/home/kingders/smart210/kernel/kernel2/rootfs ip=192.168.2.120:192.168.2.227:192.168.2.1:255.255.255.0 console=ttySAC0,115200n8 mem=64m

设置jffs2文件系统启动参数
set bootargs root=/dev/mtdblock4 rootfstype=jffs2 init=/linuxrc console=ttySAC0,115200n8 mem=64m

保存环境变量,//在uboot看来是环境变量,在内核看来是params
saveenv

/**************************** nand 整合ecc功能 成功 *********************************/

arch/arm/mach-s5pv210/mach-smdkv210.c
#include <linux/mtd/mtd.h>
/* add by huang */
static struct nand_ecclayout nand_oob_64 = {			//添加 nand_ecclayout 定义 OOB 布局 oob段对应nandflash页的 spare area
	.eccbytes = 52,		/* 2048 / 512 * 13 */
	.eccpos = {	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
				22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
				32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 
				42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
				52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
				62, 63},
	/* 0和1用于保存坏块标记，12~63保存ecc，剩余2~11为free */
	.oobfree = {
			{.offset = 2,
			.length = 10}
		}
};
static struct s3c2410_nand_set smdk_nand_sets[] = {
	[0] = {
		.name		= "NAND",
		.nr_chips	= 1,
		.nr_partitions	= ARRAY_SIZE(smdk_default_nand_part),
		.partitions	= smdk_default_nand_part,
		.disable_ecc = 0,		//启动ecc
		.ecc_layout = &nand_oob_64,	//添加放ecc码的oob段
	},
};

NAND 驱动 drivers/mtd/nand/s3c2410.c	//里面所用到的寄存器索引都在arch/arm/plat-samsung/include/plat/regs-nand.h 中定义
/* ECC handling functions */
#ifdef CONFIG_MTD_NAND_S3C2410_HWECC
/* add by zjh */
static void s5pv210_nand_enable_hwecc(struct mtd_info *mtd, int mode)
{
	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
	u32 cfg;
	
	if (mode == NAND_ECC_READ)
	{
		/* set 8/12/16bit Ecc direction to Encoding */
		cfg = readl(info->regs + S5PV210_NFECCCONT) & (~(0x1 << 16));
		writel(cfg, info->regs + S5PV210_NFECCCONT);
		
		/* clear 8/12/16bit ecc encode done */
		cfg = readl(info->regs + S5PV210_NFECCSTAT) | (0x1 << 24);
		writel(cfg, info->regs + S5PV210_NFECCSTAT);
	}
	else
	{
		/* set 8/12/16bit Ecc direction to Encoding */
		cfg = readl(info->regs + S5PV210_NFECCCONT) | (0x1 << 16);
		writel(cfg, info->regs + S5PV210_NFECCCONT);
		
		/* clear 8/12/16bit ecc encode done */
		cfg = readl(info->regs + S5PV210_NFECCSTAT) | (0x1 << 25);
		writel(cfg, info->regs + S5PV210_NFECCSTAT);
	}
	
	/* Initialize main area ECC decoder/encoder */
	cfg = readl(info->regs + S5PV210_NFCONT) | (0x1 << 5);
	writel(cfg, info->regs + S5PV210_NFCONT);
	
	/* The ECC message size(For 512-byte message, you should set 511) 8-bit ECC/512B  */
	writel((511 << 16) | 0x3, info->regs + S5PV210_NFECCCONF);
			

	/* Initialize main area ECC decoder/ encoder */
	cfg = readl(info->regs + S5PV210_NFECCCONT) | (0x1 << 2);
	writel(cfg, info->regs + S5PV210_NFECCCONT);
	
	/* Unlock Main area ECC   */
	cfg = readl(info->regs + S5PV210_NFCONT) & (~(0x1 << 7));
	writel(cfg, info->regs + S5PV210_NFCONT);
}
/* add by zjh */
static int s5pv210_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
				      u_char *ecc_calc)
{
	u32 cfg;
	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
	u32 nfeccprgecc0 = 0, nfeccprgecc1 = 0, nfeccprgecc2 = 0, nfeccprgecc3 = 0;
	
	/* Lock Main area ECC */
	cfg = readl(info->regs + S5PV210_NFCONT) | (0x1 << 7);
	writel(cfg, info->regs + S5PV210_NFCONT);
	
	if (ecc_calc)	/* NAND_ECC_WRITE */
	{
		/* ECC encoding is completed  */
		while (!(readl(info->regs + S5PV210_NFECCSTAT) & (1 << 25)));
			
		/* 读取13 Byte的Ecc Code */
		nfeccprgecc0 = readl(info->regs + S5PV210_NFECCPRGECC0);
		nfeccprgecc1 = readl(info->regs + S5PV210_NFECCPRGECC1);
		nfeccprgecc2 = readl(info->regs + S5PV210_NFECCPRGECC2);
		nfeccprgecc3 = readl(info->regs + S5PV210_NFECCPRGECC3);

		ecc_calc[0] = nfeccprgecc0 & 0xFF;
		ecc_calc[1] = (nfeccprgecc0 >> 8) & 0xFF;
		ecc_calc[2] = (nfeccprgecc0 >> 16) & 0xFF;
		ecc_calc[3] = (nfeccprgecc0 >> 24) & 0xFF;
		ecc_calc[4] = nfeccprgecc1 & 0xFF;
		ecc_calc[5] = (nfeccprgecc1 >> 8) & 0xFF;
		ecc_calc[6] = (nfeccprgecc1 >> 16) & 0xFF;
		ecc_calc[7] = (nfeccprgecc1 >> 24) & 0xFF;
		ecc_calc[8] = nfeccprgecc2 & 0xFF;
		ecc_calc[9] = (nfeccprgecc2 >> 8) & 0xFF;
		ecc_calc[10] = (nfeccprgecc2 >> 16) & 0xFF;
		ecc_calc[11] = (nfeccprgecc2 >> 24) & 0xFF;
		ecc_calc[12] = nfeccprgecc3 & 0xFF;
	}
	else	/* NAND_ECC_READ */
	{
		/* ECC decoding is completed  */
		while (!(readl(info->regs + S5PV210_NFECCSTAT) & (1 << 24)));
	}
	return 0;
}
/* add by zjh */
static int s5pv210_nand_correct_data(struct mtd_info *mtd, u_char *dat,
				     u_char *read_ecc, u_char *calc_ecc)
{
	int ret = 0;
	u32 errNo;
	u32 erl0, erl1, erl2, erl3, erp0, erp1;
	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);

	/* Wait until the 8-bit ECC decoding engine is Idle */
	while (readl(info->regs + S5PV210_NFECCSTAT) & (1 << 31));
	
	errNo = readl(info->regs + S5PV210_NFECCSECSTAT) & 0x1F;
	erl0 = readl(info->regs + S5PV210_NFECCERL0);
	erl1 = readl(info->regs + S5PV210_NFECCERL1);
	erl2 = readl(info->regs + S5PV210_NFECCERL2);
	erl3 = readl(info->regs + S5PV210_NFECCERL3);
	
	erp0 = readl(info->regs + S5PV210_NFECCERP0);
	erp1 = readl(info->regs + S5PV210_NFECCERP1);
	
	switch (errNo)
	{
	case 8:
		dat[(erl3 >> 16) & 0x3FF] ^= (erp1 >> 24) & 0xFF;
	case 7:
		dat[erl3 & 0x3FF] ^= (erp1 >> 16) & 0xFF;
	case 6:
		dat[(erl2 >> 16) & 0x3FF] ^= (erp1 >> 8) & 0xFF;
	case 5:
		dat[erl2 & 0x3FF] ^= erp1 & 0xFF;
	case 4:
		dat[(erl1 >> 16) & 0x3FF] ^= (erp0 >> 24) & 0xFF;
	case 3:
		dat[erl1 & 0x3FF] ^= (erp0 >> 16) & 0xFF;
	case 2:
		dat[(erl0 >> 16) & 0x3FF] ^= (erp0 >> 8) & 0xFF;
	case 1:
		dat[erl0 & 0x3FF] ^= erp0 & 0xFF;
	case 0:
		break;
	default:
		ret = -1;
		printk("ECC uncorrectable error detected:%d\n", errNo);
		break;
	}	
	return ret;
}
/* add by zjh */
static int s5pv210_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
				uint8_t *buf, int oob_required, int page)				 
{
	int i, eccsize = chip->ecc.size;
	int eccbytes = chip->ecc.bytes;
	int eccsteps = chip->ecc.steps;
	int col = 0;
	int stat;
	uint8_t *p = buf;
	uint8_t *ecc_code = chip->buffers->ecccode;
	uint32_t *eccpos = chip->ecc.layout->eccpos;

	/* Read the OOB area first */
	col = mtd->writesize;
	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
	
	for (i = 0; i < chip->ecc.total; i++)
		ecc_code[i] = chip->oob_poi[eccpos[i]];

	for (i = 0, col = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize, col += eccsize)
	{	
		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
		chip->ecc.hwctl(mtd, NAND_ECC_READ);
		chip->read_buf(mtd, p, eccsize);
		chip->write_buf(mtd, ecc_code + i, eccbytes);
		chip->ecc.calculate(mtd, NULL, NULL);
		stat = chip->ecc.correct(mtd, p, NULL, NULL);
		if (stat < 0)
			mtd->ecc_stats.failed++;
		else
			mtd->ecc_stats.corrected += stat;
	}
	return 0;
}
static void s3c2410_nand_init_chip(struct s3c2410_nand_info *info, struct s3c2410_nand_mtd *nmtd, struct s3c2410_nand_set *set)
{......
#ifdef CONFIG_MTD_NAND_S3C2410_HWECC
	chip->ecc.calculate = s3c2410_nand_calculate_ecc;
	chip->ecc.correct   = s3c2410_nand_correct_data;
	chip->ecc.mode	    = NAND_ECC_HW;
	chip->ecc.strength  = 1;

	switch (info->cpu_type) {
	case TYPE_S3C2410:
		chip->ecc.hwctl	    = s3c2410_nand_enable_hwecc;
		chip->ecc.calculate = s3c2410_nand_calculate_ecc;
		break;

	case TYPE_S3C2412:
		chip->ecc.hwctl     = s3c2412_nand_enable_hwecc;
		chip->ecc.calculate = s3c2412_nand_calculate_ecc;
		break;

	case TYPE_S3C2440:
		chip->ecc.hwctl     = s3c2440_nand_enable_hwecc;
		chip->ecc.calculate = s3c2440_nand_calculate_ecc;
		break;
	/* add by zjh */
	case TYPE_S5PV210:
		chip->ecc.hwctl     = s5pv210_nand_enable_hwecc;
		chip->ecc.calculate = s5pv210_nand_calculate_ecc;
		chip->ecc.correct 	= s5pv210_nand_correct_data;
		chip->ecc.read_page = s5pv210_nand_read_page_hwecc;
		break;	
	}
.....}
static void s3c2410_nand_update_chip(struct s3c2410_nand_info *info,
				     struct s3c2410_nand_mtd *nmtd)
{
	struct nand_chip *chip = &nmtd->chip;

	dev_dbg(info->device, "chip %p => page shift %d\n",
		chip, chip->page_shift);

	if (chip->ecc.mode != NAND_ECC_HW)
		return;

		/* change the behaviour depending on whether we are using
		 * the large or small page nand device */

	if (chip->page_shift > 10) {
		chip->ecc.size	    = 512;		/* add by huang */
		chip->ecc.bytes	    = 13;		/* add by huang */
	} else {
		chip->ecc.size	    = 512;
		chip->ecc.bytes	    = 3;
		chip->ecc.layout    = &nand_hw_eccoob;
	}
}

make menuconfig		//这里是注册ecc硬件读函数
Device Drivers --->
	<*> Memory Technology Device (MTD) support --->
		<*> NAND Device Support --->
			[*] Samsung S3C NAND Hardware ECC
make uImage -j4

调试,发现一开始:s3c2410_nand_update_chip里的
		chip->ecc.size	    = 512;		/* add by huang */
		chip->ecc.bytes	    = 13;		/* add by huang */
一开始设置错误,所以卡死在VFP support v0.3: implementor 41 architecture 3 part 30 variant c rev 2
后来,把Samsung S3C NAND Hardware ECC 关闭了,即使用软件ecc读函数,但是,软件ecc读未修改到为s5pv210专用,
所以启动后出现 uncorrect ecc error
都修改后,然后成功启动了

/**************************** SD/MMC *********************************/

三星已经提供了支持 s5pv210 的 SD/MMC 的驱动:drivers/mmc/host/sdhci-s3c.c
在 mach-smdkv210.c 中已经添加到 smdkv210_devices 设备列表:
static struct platform_device *smdkv210_devices[] __initdata = {
	&s3c_device_adc,
	&s3c_device_cfcon,
	&s3c_device_fb,
	&s3c_device_hsmmc0,	//mmc设备0
	&s3c_device_hsmmc1,	//...
	&s3c_device_hsmmc2,
	&s3c_device_hsmmc3,

配置内核
Device Drivers --->
	<*> MMC/SD/SDIO card support --->
		<*> Secure Digital Host Controller Interface support
		<*> SDHCI platform and OF driver helper
		<*> SDHCI support on Samsung S3C SoC
		[*] DMA support on S3C SDHCI
make uImage -j4

调试:
从sd卡启动成功后,拔出sd卡,串口中断有显示sd卡被拔出,sd卡在内里注册位mmcblk0设备,
再次插入sd卡,显示注册了mmc设备
cat /proc/partitions 后显示储存设备的分区注册状态
mmcblk0 代表整个 SD 卡,mmcblk0p1 代表第 1 个分区
挂载 SD 卡到 指定 目录(例如/sdcard)
mkdir /sdcard
mount -t vfat /dev/mmcblk0p1 /sdcard/	//-t 指定挂载格式为 vfat,SD 卡必须格式化为 fat 或者 fat32 格式
					//否则会出现如下错误。mount: mounting /dev/mmcblk0p1 on mnt/ failed: Invalid argument
linux 内核默认配置为支持 vfat 格式,另外用户也可以选择支持 NTFS 格式:
配置内核
File systems --->
	<*> DOS/FAT/NT Filesystems --->
		<*> NFT file system support

添加脚本,实现自动挂载和卸载



/**************************** 重新编译 *********************************/
进度;完成了 nfs  rootfs是rootfs/rootfs1,使用tools/busybox/busybox-1.21.1


/**************************** 后面的操作直接使用 roorfs/rootfs1作为nfs来挂载来测试 *********************************/

/**************************** fucking_one_wire_lcd  点亮lcd*********************************/
参考:	http://www.epubit.com.cn/article/236?utm_source=tuicool&utm_medium=referral
	http://www.tuicool.com/articles/BBvEjeN
	http://www.linuxidc.com/Linux/2012-01/52087.htm
	http://www.linuxidc.com/Linux/2012-01/52086.htm
(拷贝来自友善之臂的linux-3.08源码)
drivers/input/touchscreen/mini210_1wire_host.c
/home/kingders/smart210/kernel/kernel2/linux-3.10.102/arch/arm/plat-samsung/include/plat/ctouch.h
/home/kingders/smart210/kernel/kernel2/linux-3.10.102/arch/arm/include/asm/leds_h	//似乎没有用到

drivers/input/touchscreen:Makefile添加:
# add by huang
obj-$(CONFIG_TOUCHSCREEN_1WIRE)		+= mini210_1wire_host.o

drivers/input/touchscreen:Kconfig增加:
config TOUCHSCREEN_1WIRE
	tristate"Mini210 1-Wire host and Touch Screen Driver"
	help
	  Say Y here to enable the 1-Wire host andTouch Screen driver for
	  FriendlyARM Mini210 development board.

	  If unsure, say N.

	  To compile this driver as a module, choose Mhere: the
	  module will be called mini210_1wire_host.

arch/arm/mach-s5pv210/mach-smdkv210.c添加:
static struct platform_device *smdkv210_devices[] __initdata = {
.........
	/* add by huang */
	&s3c_device_1wire,	//逗号是需要的
.........
/* add by huang */
static struct platform_devices3c_device_1wire = {
	.name		= "mini210_1wire",
	.id		= -1,
	.num_resources	= 0,
};


调试:
先在make menuconfig,选中 Mini210 1-Wire host and Touch Screen Driver

几乎围绕mini210_1wire_host.c调试:

error: implicit declaration of function '__devexit_p',
在liuux3.08发现include/linux/init.h:#define __devexit_p(x) x
所以取消__devexit_p的写法


关于3.10,与3.08的proc文件系统改变的移植,
mini210_1wire_host.c:	
	create_proc_read_entry("driver/one-wire-info", 0, NULL, read_proc, NULL);

发现3.10完全删掉了:
	read_proc_t *read_proc;
	write_proc_t *write_proc;
所以根本不是简单移植的问题,后来发现,直接不用这个create_proc_read_entry初始化也可以!!


///////////////////linux3.08
include/linux/proc_fs.h:
static inline struct proc_dir_entry *create_proc_read_entry(const char *name,
	mode_t mode, struct proc_dir_entry *base, 
	read_proc_t *read_proc, void * data)
{
	struct proc_dir_entry *res=create_proc_entry(name,mode,base);
	if (res) {
		res->read_proc=read_proc;
		res->data=data;
	}
	return res;
}
fs/proc/generic.c:
struct proc_dir_entry *create_proc_entry(const char *name, mode_t mode,
					 struct proc_dir_entry *parent)
{
	struct proc_dir_entry *ent;
	nlink_t nlink;

	if (S_ISDIR(mode)) {
		if ((mode & S_IALLUGO) == 0)
			mode |= S_IRUGO | S_IXUGO;
		nlink = 2;
	} else {
		if ((mode & S_IFMT) == 0)
			mode |= S_IFREG;
		if ((mode & S_IALLUGO) == 0)
			mode |= S_IRUGO;
		nlink = 1;
	}

	ent = __proc_create(&parent, name, mode, nlink);
	if (ent) {
		if (proc_register(parent, ent) < 0) {
			kfree(ent);
			ent = NULL;
		}
	}
	return ent;
}
EXPORT_SYMBOL(create_proc_entry);
struct proc_dir_entry {
	unsigned int low_ino;
	unsigned int namelen;
	const char *name;
	mode_t mode;
	nlink_t nlink;
	uid_t uid;
	gid_t gid;
	loff_t size;
	const struct inode_operations *proc_iops;
	/*
	 * NULL ->proc_fops means "PDE is going away RSN" or
	 * "PDE is just created". In either case, e.g. ->read_proc won't be
	 * called because it's too late or too early, respectively.
	 *
	 * If you're allocating ->proc_fops dynamically, save a pointer
	 * somewhere.
	 */
	const struct file_operations *proc_fops;
	struct proc_dir_entry *next, *parent, *subdir;
	void *data;
	read_proc_t *read_proc;
	write_proc_t *write_proc;
	atomic_t count;		/* use count */
	int pde_users;	/* number of callers into module in progress */
	spinlock_t pde_unload_lock; /* proc_fops checks and pde_users bumps */
	struct completion *pde_unload_completion;
	struct list_head pde_openers;	/* who did ->open, but not ->release */
};
struct proc_dir_entry {
	unsigned int low_ino;
	unsigned int namelen;
	const char *name;
	mode_t mode;
	nlink_t nlink;
	uid_t uid;
	gid_t gid;
	loff_t size;
	const struct inode_operations *proc_iops;
	/*
	 * NULL ->proc_fops means "PDE is going away RSN" or
	 * "PDE is just created". In either case, e.g. ->read_proc won't be
	 * called because it's too late or too early, respectively.
	 *
	 * If you're allocating ->proc_fops dynamically, save a pointer
	 * somewhere.
	 */
	const struct file_operations *proc_fops;
	struct proc_dir_entry *next, *parent, *subdir;
	void *data;
	read_proc_t *read_proc;
	write_proc_t *write_proc;
	atomic_t count;		/* use count */
	int pde_users;	/* number of callers into module in progress */
	spinlock_t pde_unload_lock; /* proc_fops checks and pde_users bumps */
	struct completion *pde_unload_completion;
	struct list_head pde_openers;	/* who did ->open, but not ->release */
};
///////////////////linux3.10
include/linux/proc_fs.h:
static inline struct proc_dir_entry *proc_create(
	const char *name, umode_t mode, struct proc_dir_entry *parent,
	const struct file_operations *proc_fops)
{
	return proc_create_data(name, mode, parent, proc_fops, NULL);
}
fs/proc/generic.c:
struct proc_dir_entry *proc_create_data(const char *name, mode_t mode,
					struct proc_dir_entry *parent,
					const struct file_operations *proc_fops,
					void *data)
{
	struct proc_dir_entry *pde;
	nlink_t nlink;

	if (S_ISDIR(mode)) {
		if ((mode & S_IALLUGO) == 0)
			mode |= S_IRUGO | S_IXUGO;
		nlink = 2;
	} else {
		if ((mode & S_IFMT) == 0)
			mode |= S_IFREG;
		if ((mode & S_IALLUGO) == 0)
			mode |= S_IRUGO;
		nlink = 1;
	}

	pde = __proc_create(&parent, name, mode, nlink);
	if (!pde)
		goto out;
	pde->proc_fops = proc_fops;
	pde->data = data;
	if (proc_register(parent, pde) < 0)
		goto out_free;
	return pde;
out_free:
	kfree(pde);
out:
	return NULL;
}
EXPORT_SYMBOL(proc_create_data);
fs/proc/internal.h
struct proc_dir_entry {
	unsigned int low_ino;
	umode_t mode;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	const struct inode_operations *proc_iops;
	const struct file_operations *proc_fops;
	struct proc_dir_entry *next, *parent, *subdir;
	void *data;
	atomic_t count;		/* use count */
	atomic_t in_use;	/* number of callers into module in progress; */
			/* negative -> it's going away RSN */
	struct completion *pde_unload_completion;
	struct list_head pde_openers;	/* who did ->open, but not ->release */
	spinlock_t pde_unload_lock; /* proc_fops checks and pde_users bumps */
	u8 namelen;
	char name[];
};
include/linux/fs.h
struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
	int (*readdir) (struct file *, void *, filldir_t);
	unsigned int (*poll) (struct file *, struct poll_table_struct *);
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
	int (*mmap) (struct file *, struct vm_area_struct *);
	int (*open) (struct inode *, struct file *);
	int (*flush) (struct file *, fl_owner_t id);
	int (*release) (struct inode *, struct file *);
	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
	int (*aio_fsync) (struct kiocb *, int datasync);
	int (*fasync) (int, struct file *, int);
	int (*lock) (struct file *, int, struct file_lock *);
	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
	int (*check_flags)(int);
	int (*flock) (struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long, struct file_lock **);
	long (*fallocate)(struct file *file, int mode, loff_t offset,
			  loff_t len);
	int (*show_fdinfo)(struct seq_file *m, struct file *f);
};


继续调试:
undefined reference to `mini210_get_ctp'
grep 发现缺乏 mini210-lcds.c,所以拷贝到:arch/arm/mach-s5pv210/mini210-lcds.c
grep 发现缺乏 s3cfb.h,所以拷贝到:arch/arm/mach-s5pv210/include/mach/s3cfb.h
修改:arch/arm/mach-s5pv210/mini210-lcds.c添加
/* add by huang */
#include <mach/s3cfb.h>
修改arch/arm/mach-s5pv210/Makefile
obj-$(CONFIG_MACH_SMDKV210)	+= mach-smdkv210.o mini210-lcds.o

依然:
undefined reference to `mini210_get_ctp'
发现mini210-lcds.c的mini210_get_ctp被宏CONFIG_TOUCHSCREEN_GOODIX  CONFIG_TOUCHSCREEN_FT5X0X控制!!
注释掉宏!!
最后成功点亮lcd!!!

grep 过,发现只有mini210_1wire_host.c初始化,而,mini210-lcds.c并没有初始化

/**************************** fucking_one_wire_lcd  驱动lcd*********************************/
按照嵌入笔记继续驱动lcd:
drivers/video/s3c-fb.c:
static struct platform_device_id s3c_fb_driver_ids[] = {
	{
		.name		= "s3c-fb",
		.driver_data	= (unsigned long)&s3c_fb_data_64xx,
	}, {
		.name		= "s5pc100-fb",
		.driver_data	= (unsigned long)&s3c_fb_data_s5pc100,
	}, {
		.name		= "s5pv210-fb",
		.driver_data	= (unsigned long)&s3c_fb_data_s5pv210,
	}, {
		.name		= "exynos4-fb",
		.driver_data	= (unsigned long)&s3c_fb_data_exynos4,
	}, {
		.name		= "exynos5-fb",
		.driver_data	= (unsigned long)&s3c_fb_data_exynos5,
	}, {
		.name		= "s3c2443-fb",
		.driver_data	= (unsigned long)&s3c_fb_data_s3c2443,
	}, {
		.name		= "s5p64x0-fb",
		.driver_data	= (unsigned long)&s3c_fb_data_s5p64x0,
	},
	{},
};
MODULE_DEVICE_TABLE(platform, s3c_fb_driver_ids);

arch/arm/plat-samsung/devs.c
struct platform_device s3c_device_fb = {
	.name		= "s3c-fb",
	.id		= -1,
	.num_resources	= ARRAY_SIZE(s3c_fb_resource),
	.resource	= s3c_fb_resource,
	.dev		= {
		.dma_mask		= &samsung_device_dma_mask,
		.coherent_dma_mask	= DMA_BIT_MASK(32),
	},
};

这里的 name 属性为“s3c-fb”,我们的 s5pv210 要匹配上面的 s3c_fb_driver_ids 中 s5pv210-fb,只有
把 s3c_device_fb 中的 name 属性设置为“s5pv210-fb”,三星提供了一个函数来设置,在
arch/arm/mach-s5pv210/common.c 中的 s5pv210_map_io 函数中进行了设置
void __init s5pv210_map_io(void)
{
	/* initialise device information early */
	s5pv210_default_sdhci0();
	s5pv210_default_sdhci1();
	s5pv210_default_sdhci2();
	s5pv210_default_sdhci3();

	s3c_adc_setname("samsung-adc-v3");

	s3c_cfcon_setname("s5pv210-pata");

	s3c_fimc_setname(0, "s5pv210-fimc");
	s3c_fimc_setname(1, "s5pv210-fimc");
	s3c_fimc_setname(2, "s5pv210-fimc");

	/* the i2c devices are directly compatible with s3c2440 */
	s3c_i2c0_setname("s3c2440-i2c");
	s3c_i2c1_setname("s3c2440-i2c");
	s3c_i2c2_setname("s3c2440-i2c");

	s3c_fb_setname("s5pv210-fb");

	/* Use s5pv210-keypad instead of samsung-keypad */
	samsung_keypad_setname("s5pv210-keypad");

	/* setup TV devices */
	s5p_hdmi_setname("s5pv210-hdmi");

	s3c64xx_spi_setname("s5pv210-spi");
}
可以看到,三星的很多驱动都是采用这种方式,首先定义一个公用的平台设备,然后在根据特点的 CPU
来设置平台设备的 name 属性,这样做减少了重复代码。

arch/arm/mach-s5pv210/mach-smdkv210.c
/* modied by zjh */
static void smdkv210_lte480wv_set_power(struct plat_lcd_data *pd,
					unsigned int power)
{
	if (power) {
#if !defined(CONFIG_BACKLIGHT_PWM)
		gpio_request_one(S5PV210_GPD0(1), GPIOF_OUT_INIT_HIGH, "GPD0");		//GPD0_1	背光灯控制针
		gpio_free(S5PV210_GPD0(1));
#endif
#if 0
		/* fire nRESET on power up */
		gpio_request_one(S5PV210_GPH0(6), GPIOF_OUT_INIT_HIGH, "GPH0");

		gpio_set_value(S5PV210_GPH0(6), 0);
		mdelay(10);

		gpio_set_value(S5PV210_GPH0(6), 1);
		mdelay(10);

		gpio_free(S5PV210_GPH0(6));
#endif		
	} else {
#if !defined(CONFIG_BACKLIGHT_PWM)
		gpio_request_one(S5PV210_GPD0(1), GPIOF_OUT_INIT_LOW, "GPD0");
		gpio_free(S5PV210_GPD0(1));
#endif
	}
}
static struct plat_lcd_data smdkv210_lcd_lte480wv_data = {
	.set_power	= smdkv210_lte480wv_set_power,
};

static struct platform_device smdkv210_lcd_lte480wv = {
	.name			= "platform-lcd",
	.dev.parent		= &s3c_device_fb.dev,
	.dev.platform_data	= &smdkv210_lcd_lte480wv_data,
};
static struct s3c_fb_pd_win smdkv210_fb_win0 = {
	.max_bpp	= 32,
	.default_bpp	= 24,
	.xres		= 800,
	.yres		= 480,
};
static struct fb_videomode smdkv210_lcd_timing = {
	.left_margin	= 46,
	.right_margin	= 8,
	.upper_margin	= 23,
	.lower_margin	= 22,
	.hsync_len	= 2,
	.vsync_len	= 2,
	.xres		= 800,
	.yres		= 480,
};
static struct s3c_fb_platdata smdkv210_lcd0_pdata __initdata = {
	.win[0]		= &smdkv210_fb_win0,
	.vtiming	= &smdkv210_lcd_timing,
	.vidcon0	= VIDCON0_VIDOUT_RGB | VIDCON0_PNRMODE_RGB,
	.vidcon1	= VIDCON1_INV_HSYNC | VIDCON1_INV_VSYNC,
	.setup_gpio	= s5pv210_fb_gpio_setup_24bpp,
};

根据 LCD 手册配置这些参数。注意到这里没有配置像素时钟,是因为在驱动 s3c-fb.c 中根据上面的时序参数计算出来的。
drivers/video/s3c-fb.c:
static void s3c_fb_set_rgb_timing(struct s3c_fb *sfb)
{
	struct fb_videomode *vmode = sfb->pdata->vtiming;
	void __iomem *regs = sfb->regs;
	int clkdiv;
	u32 data;

	if (!vmode->pixclock)
		s3c_fb_missing_pixclock(vmode);
......
static void s3c_fb_missing_pixclock(struct fb_videomode *mode)	//通过这个函数计算出像素时钟来
{
	u64 pixclk = 1000000000000ULL;
	u32 div;

	div  = mode->left_margin + mode->hsync_len + mode->right_margin +
	       mode->xres;
	div *= mode->upper_margin + mode->vsync_len + mode->lower_margin +
	       mode->yres;
	div *= mode->refresh ? : 60;

	do_div(pixclk, div);

	mode->pixclock = pixclk;
}

上面的平台数据都是 s3c_device_fb 这个平台设备的

XpwmTOUT1 对应GPD0_1	背光灯控制针,但已经被 友善的1wire_lcd 劫持,相当于无作用
XEINT10	  对应GPH1_2	lcd的外部中断针

另外还定义了一个 smdkv210_lcd_lte480wv 平台设备,这个设备主要是提供 LCD 的背光操作
其对应的驱动为drivers/video/backlight/platform_lcd.c
然而背光已经被劫持,不过还是设置吧,防止实验有bug

配置;make menuconfig
Device Drivers --->
	Graphics support --->
		<*> Support for frame buffer devices  --->
			<*> Samsung S3C framebuffer support
		[*] Backlight & LCD device support --->
			<*> Lowlevel LCD controls
			<*> Platform LCD controls
			<*> Lowlevel Backlight controls
			<*> Generic (aka Sharp Corgi) Backlight Driver
		Console display driver support --->
			<*> Framebuffer Console support
		[*] Bootup logo --->	//显示企鹅logo
成功lcd!!!


/**************************** ts_设备节点 tslib *********************************/

以上只是初始化了设备,但也没有生成设备节点,通过mdev -s指令 生成节点
然后好多软件都通过tslib来 桥接 软件的操作与硬件操作,
tslib主要是通过操作dev/touchscreen设备节点来操作设备
软件使用tslib来操作

最后,编译安装tslib的操作记录在tools/tslib里,
下列使用了tools/tslib/tslib2里生成的库,但还没有很好移植好.


mini210_1wire初始化:dev_init:
	->misc_register(&ts_misc) | misc_register(&bl_misc) ;
	
drivers/char/misc.c
int misc_register(struct miscdevice * misc)
{
	dev_t dev;
	int err = 0;

	INIT_LIST_HEAD(&misc->list);

	mutex_lock(&misc_mtx);

	if (misc->minor == MISC_DYNAMIC_MINOR) {
		int i = find_first_zero_bit(misc_minors, DYNAMIC_MINORS);
		if (i >= DYNAMIC_MINORS) {
			mutex_unlock(&misc_mtx);
			return -EBUSY;
		}
		misc->minor = DYNAMIC_MINORS - i - 1;
		set_bit(i, misc_minors);
	} else {
		struct miscdevice *c;

		list_for_each_entry(c, &misc_list, list) {
			if (c->minor == misc->minor) {
				mutex_unlock(&misc_mtx);
				return -EBUSY;
			}
		}
	}

	dev = MKDEV(MISC_MAJOR, misc->minor);

	misc->this_device = device_create(misc_class, misc->parent, dev,	//一般是这里生成设备节点:/dev/misc->name
					  misc, "%s", misc->name);
	if (IS_ERR(misc->this_device)) {
		int i = DYNAMIC_MINORS - misc->minor - 1;
		if (i < DYNAMIC_MINORS && i >= 0)
			clear_bit(i, misc_minors);
		err = PTR_ERR(misc->this_device);
		goto out;
	}

	/*
	 * Add it to the front, so that later devices can "override"
	 * earlier defaults
	 */
	list_add(&misc->list, &misc_list);
 out:
	mutex_unlock(&misc_mtx);
	return err;
}
	

misc_device 是特殊的字符设备。注册驱动程序时采用misc_register函数注册，此函数中会自动创建设备节点，
即设备文件。无需mknod指令创建设备文件。 因为misc_register()会调用class_device_create()或者device_create()

然而 dev 里没有任何设备节点,
后来使用命令 mdev -s:发现了dev出现了设备节点.


mdev -s 的作用是扫描，真正需要有个监护程序来查看，如果又插入就创造节点，有拔出就删除节点，
问题出在没有监护程序，有监护程序不需要人去管 http://blog.csdn.net/t_jorney/article/details/8756402，仅作参考 

使用tslib测试发现:
[root@$huang: /dev]# ts_test
Couldnt load module one_wire_ts_input
No raw modules loaded.
ts_config: Success


因为要对驱动程序中多点触摸的数据协议有所了解，这样才能从电容屏的数据中提取出单点数据。
友善提供了friendlyarm-ts-mtinput.so 文件（但并没有源码），该文件就在友善自带的tslib中，
默认目录为/usr/lib/ts/friendlyarm-ts-mtinput.so。把这个库拷贝到自己编译的tslib插件目录中，再修改配置文件ts.conf，即可使tslib工作。

继续测试,
etc/ts_conf
module_raw friendlyarm-ts-input		//友善之臂触摸屏的 tslib 插件补丁模块名称 (直接从友善之臂的素材取来用,没有开源,所以也不值得考究)
etc/profile
export TSLIB_PLUGINDIR=/usr/lib/ts  	//告诉 tslib 插件补丁模块 的路径
export TSLIB_FBDEVICE=/dev/fb0  	//tslib 输出的图片帧 数据写到 lcd设备 fb0

最后开机后
mdev -s		//生成设备节点
ts_test		//触摸屏测试	成功	(不太成功,因为触摸屏坏了,不断输出一个值.)
ts_calibrate	//触摸屏矫正	成功	(不太成功,因为触摸屏坏了,不断输出一个值.)

继续测试,
怀疑是多点屏,使用多点屏的库再尝试一遍.
etc/ts_conf
module_raw friendlyarm-ts-mtinput	//友善之臂触摸屏的 tslib 插件补丁模块名称 (直接从友善之臂的素材取来用,没有开源,所以也不值得考究)

最后开机后
发现并没有找到多点屏,说明只是单点屏


/**************************** qt移植 *********************************/
源码地址: http://download.qt.io/development_releases/qt/5.6/5.6.0-rc/single/
rc是最稳定版本!!!
beta是公测版本
alpha是内侧版本

下载rc版本: qt-everywhere-opensource-src-5.6.0-rc.tar.gz

安装arm-linux-gcc-4.5.1
kl@kl-Lenovo-Product:~/temp/qt-everywhere-opensource-src-5.6.0-rc$ sudo tar xvzf arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz -C /
kl@kl-Lenovo-Product:~/temp/qt-everywhere-opensource-src-5.6.0-rc$ sudo gedit /root/.bashrc
最后添加：export PATH=$PATH:/opt/FriendlyARM/toolschain/4.5.1/bin
kl@kl-Lenovo-Product:~/temp/qt-everywhere-opensource-src-5.6.0-rc$ sudo gedit ~/.bashrc
最后添加：export PATH=$PATH:/opt/FriendlyARM/toolschain/4.5.1/bin
kl@kl-Lenovo-Product:~/temp/qt-everywhere-opensource-src-5.6.0-rc$ sudo apt-get install lsb-core
//因为pc是amd64架构，但友善提供的arm-linux-gcc-4.5.1是32位


////////////////////////////////qt移植
设置
qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf
#
# qmake configuration for building with arm-linux-gnueabi-g++
#

MAKEFILE_GENERATOR      = UNIX
CONFIG                 += incremental
QMAKE_INCREMENTAL_STYLE = sublib

QT_QPA_DEFAULT_PLATFORM = linuxfb   
#QMAKE_CFLAGS_RELEASE   +=-O2 -march=armv5te  
QMAKE_CFLAGS_RELEASE	+= -O2 -march=armv7-a      	#选择armv7架构
QMAKE_CXXFLAGS_RELEASE	+= -O2 -march=armv7-a  		#选择armv7架构

include(../common/linux.conf)
include(../common/gcc-base-unix.conf)
include(../common/g++-unix.conf)

# modifications to g++.conf
QMAKE_CC                = arm-none-linux-gnueabi-gcc
QMAKE_CXX               = arm-none-linux-gnueabi-g++
QMAKE_LINK              = arm-none-linux-gnueabi-g++
QMAKE_LINK_SHLIB        = arm-none-linux-gnueabi-g++

# modifications to linux.conf
QMAKE_AR                = arm-none-linux-gnueabi-ar cqs
QMAKE_OBJCOPY           = arm-none-linux-gnueabi-objcopy
QMAKE_NM                = arm-none-linux-gnueabi-nm -P
QMAKE_STRIP             = arm-none-linux-gnueabi-strip
load(qt_config)

配置：
kl@kl-Lenovo-Product:~/temp/qt-everywhere-opensource-src-5.6.0-rc$ ./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/kl/temp/Qt-5.6.0/armv7-a -no-c++11 -qreal float
//参数说明：
//-xplatform linux-arm-gnueabi-g++ 说明 生成的QT工具包和库是面向arm架构的，表示这些工具和库要用对应的编译工具生成
//-prefix /home/kl/temp/Qt-5.6.0/armv7-a 表示 生成的QT工具包和库 要install到的目标文件夹

log：
+ cd qtbase
+ /home/kl/temp/qt-everywhere-opensource-src-5.6.0-rc/qtbase/configure -top-level -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/kl/temp/Qt-5.6.0/armv7-a -no-c++11 -qreal float

This is the Qt Open Source Edition.

You are licensed to use this software under the terms of
the Lesser GNU General Public License (LGPL) versions 2.1.
You are also licensed to use this software under the terms of
the GNU Lesser General Public License (LGPL) versions 3.

Type '3' to view the GNU Lesser General Public License version 3.
Type 'L' to view the Lesser GNU General Public License version 2.1.
Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept the terms of either license? yes

Running configuration tests (phase 1)...
/home/kl/temp/qt-everywhere-opensource-src-5.6.0-rc/qtbase/configure: 3481: /home/kl/temp/qt-everywhere-opensource-src-5.6.0-rc/qtbase/configure: arm-linux-gnueabi-g++: not found			//问题根源
Done running configuration tests.
Creating qmake...
.........................................................................................Done.
Running configuration tests (phase 2)...
Warning: Disabling pkg-config since PKG_CONFIG_LIBDIR is not set and
the host's .pc files would be used (even if you set PKG_CONFIG_PATH).
Set this variable to the directory that contains target .pc files
for pkg-config to function correctly when cross-compiling or
use -pkg-config to override this test.
Warning: Disabling pkg-config since PKG_CONFIG_SYSROOT_DIR is not set.
Set this variable to your sysroot for pkg-config to function correctly when
cross-compiling or use -pkg-config to override this test.

Could not determine the target architecture!
Turn on verbose messaging (-v) to see the final report.
No QPA platform plugin enabled!
 If you really want to build without a QPA platform plugin you must pass
 -no-qpa-platform-guard to configure. Doing this will
 produce a Qt that can not run GUI applications.
 The dependencies needed for xcb to build are listed in
 src/plugins/platforms/xcb/README

//这里出现问题！！！！！！！
arm-linux-gnueabi-g++: not found
由于交叉编译器的名称不一致，所以表示找不到，查看已安装的友善提供的编译器发现，编译器工具们都是以arm-none-linux-gnueabi-前缀
修改交叉编译器名称，
在qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf下，修改qmake.conf文件，
注意把 arm-linux-gnueabi-xxx 替换 arm-none-linux-gnueabi-xxx

再调试：
kl@kl-Lenovo-Product:~/temp/qt-everywhere-opensource-src-5.6.0-rc$ ./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/kl/temp/Qt-5.6.0/armv7-a -no-c++11 -qreal float
+ cd qtbase
+ /home/kl/temp/qt-everywhere-opensource-src-5.6.0-rc/qtbase/configure -top-level -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/kl/temp/Qt-5.6.0/armv7-a -no-c++11 -qreal float

This is the Qt Open Source Edition.

You are licensed to use this software under the terms of
the Lesser GNU General Public License (LGPL) versions 2.1.
You are also licensed to use this software under the terms of
the GNU Lesser General Public License (LGPL) versions 3.

Type '3' to view the GNU Lesser General Public License version 3.
Type 'L' to view the Lesser GNU General Public License version 2.1.
Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept the terms of either license? yes

Running configuration tests (phase 1)...
Done running configuration tests.
Creating qmake...
.Done.
Running configuration tests (phase 2)...
Warning: Disabling pkg-config since PKG_CONFIG_LIBDIR is not set and
the host's .pc files would be used (even if you set PKG_CONFIG_PATH).
Set this variable to the directory that contains target .pc files
for pkg-config to function correctly when cross-compiling or
use -pkg-config to override this test.
Warning: Disabling pkg-config since PKG_CONFIG_SYSROOT_DIR is not set.
Set this variable to your sysroot for pkg-config to function correctly when
cross-compiling or use -pkg-config to override this test.
Done running configuration tests.

   Configure summary

Building on:   linux-g++ (x86_64, CPU features: mmx sse sse2)
Building for:  linux-arm-gnueabi-g++ (arm, CPU features: none detected)
Platform notes:

            - Also available for Linux: linux-clang linux-kcc linux-icc linux-cxx
        
Build options:
  Configuration .......... accessibility alsa audio-backend clock-gettime clock-monotonic compile_examples concurrent cross_compile dbus enable_new_dtags evdev eventfd freetype full-config getaddrinfo getifaddrs harfbuzz iconv inotify ipv6ifname large-config largefile linuxfb medium-config minimal-config mremap nis no-pkg-config openssl pcre png posix_fallocate precompile_header qpa qpa reduce_exports release rpath shared small-config system-jpeg system-png system-zlib threadsafe-cloexec tslib 
  Build parts ............ libs examples
  Mode ................... release
  Using sanitizer(s)...... none
  Using C++ standard ..... c++98
  Using gold linker....... no
  Using new DTAGS ........ yes
  Using PCH .............. yes
  Using LTCG ............. no
  Target compiler supports:
    Neon ................. no

Qt modules and options:
  Qt D-Bus ............... yes (loading dbus-1 at runtime)
  Qt Concurrent .......... yes
  Qt GUI ................. yes
  Qt Widgets ............. yes
  Large File ............. yes
  QML debugging .......... yes
  Use system proxies ..... no

Support enabled for:
  Accessibility .......... yes
  ALSA ................... yes
  CUPS ................... no
  Evdev .................. yes
  FontConfig ............. no
  FreeType ............... yes (bundled copy)
  Glib ................... no
  GStreamer .............. no
  GTK theme .............. no
  HarfBuzz ............... yes (bundled copy)
  Iconv .................. yes
  ICU .................... no
  Image formats: 
    GIF .................. yes (plugin, using bundled copy)
    JPEG ................. yes (plugin, using system library)
    PNG .................. yes (in QtGui, using system library)
  libinput................ no
  Logging backends: 
    journald ............... no
    syslog   ............... no
  mtdev .................. no
  Networking: 
    getaddrinfo .......... yes
    getifaddrs ........... yes
    IPv6 ifname .......... yes
    libproxy.............. no
    OpenSSL .............. yes (loading libraries at run-time)
  NIS .................... yes
  OpenGL / OpenVG: 
    EGL .................. no
    OpenGL ............... no
    OpenVG ............... no
  PCRE ................... yes (bundled copy)
  pkg-config ............. no 
  PulseAudio ............. no
  QPA backends: 
    DirectFB ............. no
    EGLFS ................ no
      EGLFS i.MX6 ........ no
      EGLFS i.MX6 Wayland. no
      EGLFS EGLDevice .... no
      EGLFS GBM .......... no
      EGLFS Mali ......... no
      EGLFS Raspberry Pi . no
      EGLFS X11 .......... no
    LinuxFB .............. yes
    Mir client............ no
    XCB .................. no
  Session management ..... yes
  SQL drivers: 
    DB2 .................. no
    InterBase ............ no
    MySQL ................ no
    OCI .................. no
    ODBC ................. no
    PostgreSQL ........... no
    SQLite 2 ............. no
    SQLite ............... yes (plugin, using bundled copy)
    TDS .................. no
  tslib .................. yes
  udev ................... no
  xkbcommon-x11........... no
  xkbcommon-evdev......... no
  zlib ................... yes (system library)

Info: creating super cache file /home/kl/temp/qt-everywhere-opensource-src-5.6.0-rc/.qmake.super

        NOTICE: The -no-c++11 / --c++-level=c++98 option is deprecated.

        Qt 5.7 will require C++11 support. The options are in effect for this
        Qt 5.6 build, but you should update your build scripts to remove the
        option and, if necessary, upgrade your compiler.

Qt is now configured for building. Just run 'make'.
Once everything is built, you must run 'make install'.
Qt will be installed into /home/kl/temp/Qt-5.6.0/armv7-a

Prior to reconfiguration, make sure you remove any leftovers from
the previous build.
以上输出表示配置成功

编译
make
安装
make install
最后生成的qt的工具文件和库都保存在目标文件夹/home/kl/temp/Qt-5.6.0/armv7-a

生成的工具文件有一个arm 架构的 qmake 专门为QT工程生成适合arm架构的makefile
得到 makefile 后，直接make命令，便能生成arm架构的执行程序
所以为了方便使用qmake，可以把qmake放到系统的bin文件夹，
或者添加系统环境变量 gedit /etc/profile 添加变量：
export PATH=$PATH:/home/kl/temp/Qt-5.6.0/armv7-a/bin:$PATH
使修改的/etc/profile文件立即生效的命令：source /etc/profile
最后使用qmake 命令时发现not found  原因是环境变量冲突吧，总之把qmake拷到对应的位置，最后使之能用


部署开发板运行环境

把目标文件夹Qt-5.6.0拷贝到开发板文件系统的opt目录，
例如 我用nfs，nfs的根文件夹在/home/kingders/smart210/rootfs/rootfs1
那么我拷到 /home/kingders/smart210/rootfs/rootfs1/opt 里
//注意：由于我开发板使用的kernel还不稳定，cd等操作解释的路径名字不能有特殊符号,例如“-”
//所以对应在开发板文件系统里，改名Qt-5.6.0为qt，里一层的armv7-a改名为armv7

修改添加开发板的系统变量
PATH=/bin:/sbin:/usr/bin:/usr/sbin
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$TSLIB_ROOT/lib:/opt/qt/armv7/lib/	//并合qt库路径/opt/qt/armv7/lib/到LD_LIBRARY_PATH
export PATH=$PATH:$TSLIB_ROOT/bin
export QT_QPA_PLATFORM_PLUGIN_PATH=/opt/qt/armv7/plugins/platforms  
export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0  					//qt图形插件平台以及对应的输出设备点fb0,即lcd的帧缓存
export QT_QPA_FONTDIR=/opt/qt/armv7/lib/fonts  
export QT_QPA_GENERIC_PLUGINS=tslib:/dev/touchscreen-1wire			//使用的鼠标/触摸屏设备

一个网上可参考的配置系统变量的方式：http://www.it165.net/embed/html/201606/3507.html
创建相关配置文件
1,在/qt5.6_lib下创建一个配置文件（qt5.6_path.config)，用来存放QT相关的环境变量设置。
内容如下：
#QT相关的路径
export QTDIR=/qt5.6_lib
#库路径
export LD_LIBRARY_PATH=$QTDIR/lib
#键盘
export QWS_KEYBOARD=USB:/dev/input/event1
#鼠标指定为触摸屏
export QWS_MOUSE_PROTO=Tslib:/dev/input/event0
#qt字体库目录
export QT_QWS_FONTDIR=$QTDIR/lib/fonts
#LCD尺寸
export QWS_SIZE=800x480
#qt图形插件平台
export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0
#触摸屏-一般的插件
export QT_QPA_GENERIC_PLUGINS=tslib
#平台插件
export QT_QPA_PLATFORM_PLUGIN_PATH=$QTDIR/plugins
#libiconv库的声明
export LD_PRELOAD=$QTDIR/lib/preloadable_libiconv.so
2,创建一个qt5.6_config.sh 脚本文件，用来开机自动加载QT的配置。该脚本只是用来方便移植使用，只需要在移植的时候执行一次，以后就不需要再执行。
内容如下：
#!/bin/bash
grep -q "source /qt5.6_lib/qt5.6_path.config" ../etc/profile||echo "source /qt5.6_lib/qt5.6_path.config">>../etc/profile



////////////////////////////////qt要依赖的libiconv库 移植

QT程序在运行时需要依赖libiconv库
下载：http://ftp.gnu.org/gnu/libiconv/libiconv-1.14.tar.gz
解压并进入对应 libiconv-1.14 目录

编译步骤：
在libiconv目录下：
$./configure --prefix=$PWD/temp --host=arm-linux
//参数
//--prefix=$PWD/temp  生成文件放置的目标文件夹
$make
$make install
上述命令执行完成后会在libiconv目录下生成新的temp目录，该目录下存在4个目录分别是：
bin include lib share
在lib目录下为生成的库文件，其中一个为preloadable_libiconv.so，
把它下载到开发板的lib目录下，然后再设置开发板的系统环境变量即可：
export LD_PRELOAD=/lib/preloadable_libiconv.so

最后，开发板执行qt程序时，不会提示 iconv_open failed


////////////////////////////////qt要依赖的库 移植

QT运行时需要用到ibjpeg.so.8、libpng14.so.14 等一系列库。这些库在交叉编译器目录下已经编译好，直接拷贝到开发板的lib目录下即可。
库存放的路径：
/opt/FriendlyARM/toolschain/4.5.1/arm-none-linux-gnueabi/sys-root/usr/lib
拷贝示例：
[root@xiaolong lib]# cp ./* /work/rootfs/lib/ -fd        //  "*/"符号无关

//注意，在之前的开发板测试，已经拷贝好库文件


////////////////////////////////在开发板实现一个程序
生成一个可以在开发板执行的qt程序
由于已经部署好开发板
在pc端编译一个qt程序：
使用生成的qmake生成makefile
make生成执行程序
把执行程序拷贝到开发板执行，


/**************************** usb host 2.0(ehci) 移植 (未成功) *********************************/

make menuconfig
选择各种usb选项,然而编译后无用

后来发现:
mach-smdkv210.c:static struct platform_device *smdkv210_devices[] __initdata = {
添加	&s5p_device_ehci,
编译失败, undefined reference to `s5p_device_ehci'

后来再发现:
arch/arm/mach-s5pv210/Kconfig:
menu "S5PV210 Machines"
config MACH_SMDKV210
	bool "SMDKV210"
添加:	select S5P_DEV_USB_EHCI
编译失败:
arch/arm/mach-s5pv210/mach-smdkv210.c:254:20: warning: 'smdkv210_dm9000_init' defined but not used
arch/arm/plat-samsung/devs.c:1380:8: error: 'S5P_PA_EHCI' undeclared here (not in a function)
arch/arm/plat-samsung/devs.c:1381:8: error: 'IRQ_USB_HOST' undeclared here (not in a function)
make[1]: *** [arch/arm/plat-samsung/devs.o] Error 1
查看:/home/kingders/smart210/kernel/kernel2/linux-3.10.102/arch/arm/mach-s5pv210/include/mach
的map.h与irqs.h,并根据datasheet修改:
S5P_PA_EHCI 是usb_host_ehci(usb2.0_host)模块的寄存器基地址 0xEC200000
在map.h添加 #define S5PV210_PA_USB_EHCI     	0xEC200000
IRQ_USB_HOST 是usb_host的外部中断. 对应vic1_23
在irgs.好查到 #define IRQ_UHOST		S5P_IRQ_VIC1(23)
最后修改devs.c:
static struct resource s5p_ehci_resource[] = {
	[0] = DEFINE_RES_MEM(S5PV210_PA_USB_EHCI, SZ_1M),
	[1] = DEFINE_RES_IRQ(IRQ_UHOST),
};
修改后编译,然后打开板子,插入usb设备后,出现了
usbcore: registered new interface driver usbhid
usbhid: USB HID core driver
TCP: cubic registered
NET: Registered protocol family 17
VFP support v0.3: implementor 41 architecture 3 part 30 variant c rev 2
unable to find transceiver of type USB2 PHY
s5p-ehci s5p-ehci: no platform data or transceiver defined
platform s5p-ehci: Driver s5p-ehci requests probe deferral
仍未成功,先按网络移植ohci分析问题!!



/**************************** usb host 1.0(ohci) 移植 (未成功) *********************************/
（1）拷贝ohci-exynos.c为ohci-s5p.c

（2）替换所有的exynos为s5p

（3）由于有些地方是exynos4，所以，还需要将s5p4替换为s5p

（4）添加:usb-ohci-s5p.h 将ohci-s5p.c的usb-ohci-exynos.h头文件改为：usb-ohci-s5p.h
	#include <linux/platform_data/usb-ohci-s5p.h>

/home/kingders/smart210/kernel/kernel2/linux-3.10.102/drivers/usb/host/ohci-hcd.c 添加
/* add by huang */
#ifdef CONFIG_USB_OHCI_S5P  
#include "ohci-s5p.c"  
#define S5P_PLATFORM_DRIVER     s5p_ohci_driver  
#endif  
#if	!defined(PCI_DRIVER) &&		\
	!defined(PLATFORM_DRIVER) &&	\
	!defined(OMAP1_PLATFORM_DRIVER) &&	\
	!defined(OMAP3_PLATFORM_DRIVER) &&	\
	!defined(OF_PLATFORM_DRIVER) &&	\
	!defined(SA1111_DRIVER) &&	\
	!defined(PS3_SYSTEM_BUS_DRIVER) && \
	!defined(SM501_OHCI_DRIVER) && \
	!defined(TMIO_OHCI_DRIVER) && \
	!defined(S3C2410_PLATFORM_DRIVER) && \
	!defined(EXYNOS_PLATFORM_DRIVER) && \
/*add*/	!defined(S5P_PLATFORM_DRIVER) && \
	!defined(EP93XX_PLATFORM_DRIVER) && \
	!defined(AT91_PLATFORM_DRIVER) && \
	!defined(NXP_PLATFORM_DRIVER) && \
	!defined(DAVINCI_PLATFORM_DRIVER) && \
	!defined(SPEAR_PLATFORM_DRIVER)
#error "missing bus glue for ohci-hcd"
#endif
#ifdef S5P_PLATFORM_DRIVER
	retval = platform_driver_register(&S5P_PLATFORM_DRIVER);
	if (retval < 0)
		goto error_s5p;
#endif
#ifdef S5P_PLATFORM_DRIVER
	platform_driver_unregister(&S5P_PLATFORM_DRIVER);
 error_s5p:
#endif
#ifdef S5P_PLATFORM_DRIVER
	platform_driver_unregister(&S5P_PLATFORM_DRIVER);
#endif


Kconfig添加
if USB_OHCI_HCD
config USB_OHCI_S5P
	boolean "S5P OHCI support"
	depends on PLAT_S5P
	help
	 Enable support for the Samsung S5P SOC's on-chip OHCI controller.


/////////////////////////配置平台支持
arch/arm/plat-samsung/include/plat/devs.h添加
extern struct platform_device s5p_device_ohci;

arch/arm/plat-samsung/devs.c添加
#include <linux/platform_data/usb-ohci-s5p.h>	/* add by huang */
/* USB OHCI Host Controller */

#ifdef CONFIG_S5P_DEV_USB_OHCI  
static struct resource s5p_ohci_resource[] = {  
    [0] = DEFINE_RES_MEM(0xEC300000, SZ_256),  
    [1] = DEFINE_RES_IRQ(S5P_IRQ_VIC1(23)),  
};  
  
struct platform_device s5p_device_ohci = {  
    .name       = "s5p-ohci",  
    .id     = -1,  
    .num_resources  = ARRAY_SIZE(s5p_ohci_resource),  
    .resource   = s5p_ohci_resource,  
    .dev        = {  
        .dma_mask       = &samsung_device_dma_mask,  
        .coherent_dma_mask  = DMA_BIT_MASK(32),  
    }  
};  
  
void __init s5p_ohci_set_platdata(struct s5p_ohci_platdata *pd)  
{  
    struct s5p_ohci_platdata *npd;  
  
    npd = s3c_set_platdata(pd, sizeof(struct s5p_ohci_platdata),  
            &s5p_device_ohci);  
  
    if (!npd->phy_init)  
        npd->phy_init = s5p_usb_phy_init;  
    if (!npd->phy_exit)  
        npd->phy_exit = s5p_usb_phy_exit;  
}  
#endif /* CONFIG_S5P_DEV_USB_OHCI */ 

arch/arm/plat-samsung/Kconfig添加
config S5P_DEV_USB_OHCI  
	bool  
	help  
	  Compile in platform device definition for USB OHCI  

/arch/arm/mach-s5pv210/mach-smdkv210.c修改:
/* USB EHCI OHCI */
#ifdef CONFIG_S5P_DEV_USB_EHCI  
static struct s5p_ehci_platdata s5p_ehci_platdata;  
#endif  
#ifdef CONFIG_S5P_DEV_USB_OHCI  
static struct s5p_ohci_platdata s5p_ohci_platdata;  
#endif 
static struct platform_device *smdkv210_devices[] __initdata = {
........
#ifdef CONFIG_S5P_DEV_USB_EHCI  
	&s5p_device_ehci,  
#endif  
#ifdef CONFIG_S5P_DEV_USB_OHCI  
	&s5p_device_ohci,  
#endif 
........
static void __init smdkv210_machine_init(void)
{.......
#ifdef CONFIG_S5P_DEV_USB_EHCI  
        s5p_ehci_set_platdata(&s5p_ehci_platdata);  
#endif  
#ifdef CONFIG_S5P_DEV_USB_OHCI  
        s5p_ohci_set_platdata(&s5p_ohci_platdata);  
#endif 

/////////////////////修改setup-usb-phy.c文件
arch/arm/mach-s5pv210/setup-usb-phy.c

同时修改arch/arm/plat-samsung/include/plat/usb-phy.h添加
enum s5p_usb_phy_type {
	S5P_USB_PHY_DEVICE,
	S5P_USB_PHY_HOST,
};
或者,继续修改setup-usb-phy.c,修改S5P_USB_PHY_HOST为USB_PHY_TYPE_HOST

/////////////////////内核配置项修改
driver/usb/Kconfig
config USB_ARCH_HAS_OHCI
	boolean
	# ARM:
	....
	default y if PLAT_S5P  

drivers/usb/host/Kconfig
config USB_EHCI_S5P
       tristate "EHCI support for Samsung S5P/EXYNOS SoC Series"
       depends on PLAT_S5P
       select S5P_DEV_USB_EHCI  
       help
	Enable support for the Samsung S5Pxxxx and Exynos3/4/5 SOC's
	on-chip EHCI controller.
config USB_OHCI_S5P
	boolean "S5P OHCI support"
	depends on PLAT_S5P
        select S5P_DEV_USB_OHCI
	help
	 Enable support for the Samsung S5P SOC's on-chip OHCI controller.

make menusconfig...
编译后执行log:
Starting kernel ...

Uncompressing Linux... done, booting the kernel.
Booting Linux on physical CPU 0x0
Linux version 3.10.102 (kingders@kingders-ThinkPad-T420) (gcc version 4.5.1 (ctng-1.8.1-FA) ) #4 PREEMPT Mon Sep 12 15:17:49 CST 2016
CPU: ARMv7 Processor [412fc082] revision 2 (ARMv7), cr=10c53c7d
CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache
Machine: SMDKV210
Memory policy: ECC disabled, Data cache writeback
CPU S5PV210/S5PC110 (id 0x43110220)
S3C24XX Clocks, Copyright 2004 Simtec Electronics
S5PV210: PLL settings, A=1000000000, M=667000000, E=96000000 V=54000000
S5PV210: ARMCLK=1000000000, HCLKM=200000000, HCLKD=166750000
HCLKP=133400000, PCLKM=100000000, PCLKD=83375000, PCLKP=66700000
sclk_dmc: source is sclk_a2m (0), rate is 200000000
sclk_onenand: source is hclk_psys (0), rate is 66700000
sclk_fimc: source is ext_xtal (0), rate is 24000000
sclk_fimc: source is ext_xtal (0), rate is 24000000
sclk_fimc: source is ext_xtal (0), rate is 24000000
sclk_cam0: source is ext_xtal (0), rate is 24000000
sclk_cam1: source is ext_xtal (0), rate is 24000000
sclk_fimd: source is ext_xtal (0), rate is 24000000
sclk_mfc: source is sclk_a2m (0), rate is 200000000
sclk_g2d: source is sclk_a2m (0), rate is 200000000
sclk_g3d: source is sclk_a2m (0), rate is 200000000
sclk_csis: source is ext_xtal (0), rate is 24000000
sclk_pwi: source is ext_xtal (0), rate is 24000000
sclk_pwm: source is ext_xtal (0), rate is 24000000
CPU: All CPU(s) started in SVC mode.
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 16256
Kernel command line: root=/dev/nfs nfsroot=192.168.2.227:/home/kingders/smart210/rootfs/rootfs1 ip=192.168.2.120:192.168.2.227:192.168.2.1:255.255.255.0 init=/linuxrc console=ttySAC0,115200n8 mem=64m
PID hash table entries: 256 (order: -2, 1024 bytes)
Dentry cache hash table entries: 8192 (order: 3, 32768 bytes)
Inode-cache hash table entries: 4096 (order: 2, 16384 bytes)
Memory: 64MB = 64MB total
Memory: 60444k/60444k available, 5092k reserved, 0K highmem
Virtual kernel memory layout:
    vector  : 0xffff0000 - 0xffff1000   (   4 kB)
    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
    vmalloc : 0x84800000 - 0xff000000   (1960 MB)
    lowmem  : 0x80000000 - 0x84000000   (  64 MB)
    modules : 0x7f000000 - 0x80000000   (  16 MB)
      .text : 0x80008000 - 0x803b9f3c   (3784 kB)
      .init : 0x803ba000 - 0x803e004c   ( 153 kB)
      .data : 0x803e2000 - 0x80418740   ( 218 kB)
       .bss : 0x80418740 - 0x80456068   ( 247 kB)
SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
Preemptible hierarchical RCU implementation.
NR_IRQS:208
VIC @f6000000: id 0x00041192, vendor 0x41
VIC @f6010000: id 0x00041192, vendor 0x41
VIC @f6020000: id 0x00041192, vendor 0x41
VIC @f6030000: id 0x00041192, vendor 0x41
sched_clock: 32 bits at 33MHz, resolution 29ns, wraps every 128784ms
Console: colour dummy device 80x30
Calibrating delay loop... 663.55 BogoMIPS (lpj=1658880)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 512
CPU: Testing write buffer coherency: ok
Setting up static identity map for 0x802c73b8 - 0x802c7410
NET: Registered protocol family 16
DMA: preallocated 256 KiB pool for atomic coherent allocations
S3C Power Management, Copyright 2004 Simtec Electronics
S5PV210: Initializing architecture
bio: create slab <bio-0> at 0
SCSI subsystem initialized
usbcore: registered new interface driver usbfs
usbcore: registered new interface driver hub
usbcore: registered new device driver usb
Switching to clocksource samsung_clocksource_timer
NET: Registered protocol family 2
TCP established hash table entries: 512 (order: 0, 4096 bytes)
TCP bind hash table entries: 512 (order: 1, 10240 bytes)
TCP: Hash tables configured (established 512 bind 512)
TCP: reno registered
UDP hash table entries: 256 (order: 1, 12288 bytes)
UDP-Lite hash table entries: 256 (order: 1, 12288 bytes)
NET: Registered protocol family 1
RPC: Registered named UNIX socket transport module.
RPC: Registered udp transport module.
RPC: Registered tcp transport module.
RPC: Registered tcp NFSv4.1 backchannel transport module.
ROMFS MTD (C) 2007 Red Hat, Inc.
io scheduler noop registered
io scheduler deadline registered
io scheduler cfq registered (default)
Console: switching to colour frame buffer device 100x30
s3c-fb s5pv210-fb: window 0: fb 
dma-pl330 dma-pl330.0: Loaded driver for PL330 DMAC-267056
dma-pl330 dma-pl330.0:  DBUFF-8x4bytes Num_Chans-8 Num_Peri-32 Num_Events-32
dma-pl330 dma-pl330.1: Loaded driver for PL330 DMAC-267056
dma-pl330 dma-pl330.1:  DBUFF-8x4bytes Num_Chans-8 Num_Peri-32 Num_Events-32
Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
s5pv210-uart.0: ttySAC0 at MMIO 0xe2900000 (irq = 74) is a S3C6400/10
console [ttySAC0] enabled
s5pv210-uart.1: ttySAC1 at MMIO 0xe2900400 (irq = 75) is a S3C6400/10
s5pv210-uart.2: ttySAC2 at MMIO 0xe2900800 (irq = 76) is a S3C6400/10
s5pv210-uart.3: ttySAC3 at MMIO 0xe2900c00 (irq = 77) is a S3C6400/10
brd: module loaded
loop: module loaded
dm9000 dm9000: read wrong id 0x01010101
eth0: dm9000a at 849d8000,849da004 IRQ 39 MAC: 00:09:c0:ff:ec:48 (platform data)
ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
ehci-platform: EHCI generic platform driver
ehci-s5p: EHCI s5p driver
unable to find transceiver of type USB2 PHY
s5p-ehci s5p-ehci: Failed to get usbhost clock
s5p-ehci: probe of s5p-ehci failed with error -2
ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
unable to find transceiver of type USB2 PHY
s5p-ohci s5p-ohci: Failed to get usbhost clock
s5p-ohci: probe of s5p-ohci failed with error -2
usbcore: registered new interface driver usb-storage
usbcore: registered new interface driver usbserial
mousedev: PS/2 mouse device common for all mice
touchscreen-1wire       initialized
backlight-1wire initialized
setup_irq: ret = 0
PWM clock = 66700000
TCNT_FOR_SAMPLE_BIT = 3472, TCFG1 = 00000000
sdhci: Secure Digital Host Controller Interface driver
sdhci: Copyright(c) Pierre Ossman
s3c-sdhci s3c-sdhci.0: clock source 0: mmc_busclk.0 (133400000 Hz)
s3c-sdhci s3c-sdhci.0: clock source 2: mmc_busclk.2 (96000000 Hz)
2: TCNTB=00000d90, TCNTO=0000005e, TINT_CSTAT=0000000c
mmc0: SDHCI controller on samsung-hsmmc [s3c-sdhci.0] using ADMA
s3c-sdhci s3c-sdhci.1: clock source 0: mmc_busclk.0 (133400000 Hz)
s3c-sdhci s3c-sdhci.1: clock source 2: mmc_busclk.2 (96000000 Hz)
mmc0: new high speed SD card at address b368
mmcblk0: mmc0:b368 SD    1.88 GiB 
mmc1: SDHCI controller on samsung-hsmmc [s3c-sdhci.1] using ADMA
s3c-sdhci s3c-sdhci.2: clock source 0: mmc_busclk.0 (133400000 Hz)
s3c-sdhci s3c-sdhci.2: clock source 2: mmc_busclk.2 (96000000 Hz)
 mmcblk0:
mmc2: SDHCI controller on samsung-hsmmc [s3c-sdhci.2] using ADMA
s3c-sdhci s3c-sdhci.3: clock source 0: mmc_busclk.0 (133400000 Hz)
s3c-sdhci s3c-sdhci.3: clock source 2: mmc_busclk.2 (96000000 Hz)
mmc3: SDHCI controller on samsung-hsmmc [s3c-sdhci.3] using ADMA
sdhci-pltfm: SDHCI platform and OF driver helper
usbcore: registered new interface driver usbhid
usbhid: USB HID core driver
TCP: cubic registered
NET: Registered protocol family 17
VFP support v0.3: implementor 41 architecture 3 part 30 variant c rev 2
dm9000 dm9000 eth0: link down
dm9000 dm9000 eth0: link down
IP-Config: Complete:
     device=eth0, hwaddr=00:09:c0:ff:ec:48, ipaddr=192.168.2.120, mask=255.255.255.0, gw=192.168.2.1
     host=192.168.2.120, domain=, nis-domain=(none)
     bootserver=192.168.2.227, rootserver=192.168.2.227, rootpath=
dm9000 dm9000 eth0: link up, 100Mbps, full-duplex, lpa 0x4DE1
VFS: Mounted root (nfs filesystem) on device 0:9.
Freeing unused kernel memory: 152K (803ba000 - 803e0000)
init started: BusyBox v1.21.1 (2016-09-06 12:09:49 CST)
Segmentation fault


关于usb的问题log:
ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
ehci-platform: EHCI generic platform driver
ehci-s5p: EHCI s5p driver
unable to find transceiver of type USB2 PHY
s5p-ehci s5p-ehci: Failed to get usbhost clock
s5p-ehci: probe of s5p-ehci failed with error -2
ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
unable to find transceiver of type USB2 PHY
s5p-ohci s5p-ohci: Failed to get usbhost clock
s5p-ohci: probe of s5p-ohci failed with error -2

首先Failed to get usbhost clock :
将ohci-s5p.c里的s5p_ohci_probe()函数里的：
s5p_ohci->clk = devm_clk_get(&pdev->dev, "usbhost");
改为：
s5p_ohci->clk = devm_clk_get(&pdev->dev, "usb-host");
结果log:
ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
ehci-platform: EHCI generic platform driver
ehci-s5p: EHCI s5p driver
unable to find transceiver of type USB2 PHY
s5p-ehci s5p-ehci: EHCI Host Controller
s5p-ehci s5p-ehci: new USB bus registered, assigned bus number 1
s5p-ehci s5p-ehci: irq 87, io mem 0xec200000
s5p-ehci s5p-ehci: USB 2.0 started, EHCI 1.00
hub 1-0:1.0: USB hub found
hub 1-0:1.0: 1 port detected
ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
unable to find transceiver of type USB2 PHY
s5p-ohci s5p-ohci: S5P OHCI Host Controller
s5p-ohci s5p-ohci: new USB bus registered, assigned bus number 2
s5p-ohci s5p-ohci: irq 87, io mem 0xec300000
hub 2-0:1.0: USB hub found
hub 2-0:1.0: 1 port detected
然而,插入设备没有作为,怀疑usb的电源问题:
hub 1-0:1.0: over-current condition on port 1
hub 2-0:1.0: over-current condition
menuconfig加入 USB_OTG PM_RUNTIME后再编译,问题依然,
可能是set-usb-phy.c写得不够合法,重新拷贝网上的,还加了个regs-sys.h在mach里, 编译烧写,问题依然.
通过对比,linux3.0.8没有unable to find transceiver 这一说
而linux-3.8的与linux3.10放的地方不一样
就此作罢,先成功启动linux-3.8的作对比来找问题根源.





而且ohci_s5p.c没被编译.
drivers/usb/host/Makefile添加
# add by huang
# obj-$(CONFIG_USB_OHCI_S5P)	+= ohci-s5p.o 然而先不用编译进去


/**************************** usb 基础 *********************************/

注意,这里的概念错处多,更为正确的 usb 知识在linux-3.10_分析 文档里

USB 总线概念:
	一个 USB 总线引出两个重要的链表，一个为 USB 设备链表，一个为 USB 驱动链表。
	USB设备链表 包含各种系统中的 USB 设备以及这些设备的所有接口，
		设备插入 USB 控制器之后，USB core 即会将设备在系统中注册，添加到 USB 设备链表上去
	USB驱动链表 包含 USB 设备驱动程序（usb device driver）和 USB 驱动程序（usb driver）。
		每个 USB 驱动程序的被注册时，USB 驱动程序即会添加到驱动链表上去
USB 设备概念:
	通过 hub 口   插入的外部设备,便可以称为 USB设备
	每个 USB 设备 都因为其服务的性质可能有的多样性, 	而有多种配置 configurations
	每个 配置     都因为服务不同的具体内容,   	而有不同的接口 interfaces, 同一配置,可以有多个接口并行工作
	每个 接口     都因为数据具体传输方向和要求	而有多个端口 endpoints, 端口提供一种单向数据传输的管道,
							所以,同一接口,至少需要两个端口工作.
	每个 端口     都根据数据内容性质			而分为4种类型:控制、中断、批量、等时
							所以端口除了有方向性,也有数据内容性质的自身属性,
	控制传输:
		控制端点被用来控制对 USB 设备的不同部分访问.
		通常用作配置设备、获取设备信息、发送命令到设备或获取设备状态报告。
		这些端点通常较小,每个 USB 设备都有一个控制端点称为"端点 0", 被 USB core 用来在插入时配置设备。
		USB协议保证总有足够的带宽留给控制端点传送数据到设备.
	中断传输: 
		每当 USB 主机向设备请求数据时，中断端点以固定的速率传送小量的数据
		此为USB 键盘和鼠标的主要的数据传送方法。它还用以传送数据到 USB 设备来控制设备.
		通常不用来传送大量数据。USB协议保证总有足够的带宽留给中断端点传送数据到设备.
	批量BULK传输:
		批量端点用以传送大量数据。
		这些端点常比中断端点大得多. 它们普遍用于不能有任何数据丢失的数据。
		USB 协议不保证传输在特定时间范围内完成。
		如果总线上没有足够的空间来发送整个BULK包，它被分为多个包进行传输
		这些端点普遍用于打印机、USB Mass Storage和USB网络设备上。
	等时ISOCHRONOUS传输:
		等时端点也批量传送大量数据, 但是这个数据不被保证能送达。
		这些端点用在可以处理数据丢失的设备中，并且更多依赖于保持持续的数据流.
		如音频和视频设备等等。
	
USB 驱动:
	USB 设备驱动;
		指的是 一部运行的机器,其 USB 系统运行时,使用的驱动程序,
		不管其 USB 系统 是运行在host主机模式,还是OTG,gadget下的从机模式,还是两者有之的复合模式,
		主机模式:例如电脑,通过usb访问使用外部设备,电脑的usb是处于主机模式
		从机模式:例如移动银盘,通过usb被访问,自身也运行着一个最小系统,运行着一个从机模式的usb驱动来回答着电脑的访问请求,
		复合模式:例如安卓手机,接到电脑时变为一个移动硬盘,处于从机模式,接入一个外部u盘看里面电影时,处于主机模式
		所以,每台机器,都只有一个 USB 设备驱动.
		在系统启动注册 USB core 时，USB 设备驱动程序即将被注册，也就添加到 linux驱动链表上去了
	USB 驱动:
		我们常说的 USB 驱动, 指的是,在主机模式下,挂载在 USB 驱动链表里的一系列驱动,
		这些驱动面向的服务对象是接口interfaces,
		所以 USB 驱动 也可以叫是 接口的驱动

USB 带宽:
	工作时,USB 驱动 都会把要传输的数据放入 urb 里,再提交USBcore, USBcore传递到 USB主控制器
	USB主控制器 驱动 安排统合一个数据包,然后执行transmission送出.
	USB主控制器例如 ehci ohci,对应相关驱动
	transmission 是流水作业的连续不断地发生的,不管当时是不是需要传数据,类似来坐登山缆车,坐摩天轮
	所以,一个 transmission 传输包里,可以放置传输到多个设的数据,设备通过检测头,提取属于自己的数据.
	因此,USB 的带宽是被共享的,同时usb作业的设备越多,每个设备得到的数据传输速度也会降低.
	中断传输意味着,每次transmission数据包里 都有其设备接口传输的一席之地,不管是否每次都要传输什么有效信息
	transmission数据包是 处于主机模式的机器的 USB主控制器来生成的,
	除了有主机发往从机的数据内容,还可以是,主机发往从机的轮询命令,询问从机是否有数据给主机之类
	usb协议是全双工的,发transmission数据包时,主机也接收着来自从机的数据内容
	
USB 过程:
	机器启动,
	注册 USB core 时，USB 设备驱动程序将被注册，			添加到 linux 驱动链表上
	每个 USB 驱动程序的被注册时，					添加到   USB 驱动链表上	
	设备插入 USB 控制器之后，USB core 即会将设备在系统中注册，	添加到   USB 设备链表上
	USB 设备驱动程序和 USB 设备的匹配之后，USB core 会对设备 进行配置，
		分析设备的结构之后会将设备所有 接口 都			添加到   USB 设备链表上
	当A设备、及接口都添加到 USB 设备链表，且 A一类驱动程序也添加到 USB 驱动链表上， 系统便进入已配置（configured）的状态
	以上过程，系统将会建立起该设备的的设备、配置、接口、设置、端点的结构体描述信息，
		它们分别为:	usb_device、
			  	usb_configuration、
				usb_interface、
				usb_host_interface、
				usb_host_endpoint.
	然后,USB 驱动程序 和 相应接口 进行配对:
		USB core 会调用 usb_device_match 函数，通过比较设备中的接口信息和 USB 驱动程序中的 id_table，
		初步决定该 USB 驱动程序是不是跟相应接口相匹配.
		通过这一道关卡后，USB core 会认为这个设备应该由这个驱动程序负责。
	接着，将会调用 USB 驱动程序中的 probe 函数对相应接口进行进一步检查。
		如果该驱动程序确实适合设备接口，对设备做一些初始化工作，分配 urb 准备数据传输。

urb:
	usb驱动,实际上通过给USBcore递交urb请求,请求受理并完成后调用回调处理函数的方式,
	实现了usb主机对从机设备的访问,控制,和传递数据的功能.

USB 鼠标例子
以下是一个usb鼠标驱动的例子,
	usb_mouse_init	应该是在 USB 驱动程序的被注册时 由USBcore调用的,
	插入usb鼠标后,
	probe程序	应该是在 USB 驱动程序 和 相应接口 进行配对 后由USBcore调用的,
			probe程序成功后,usb鼠标变可以工作,
			而且还会另外注册了一个linux输入(input)设备,把usb鼠标得到信息,源源不断写入输入设备文件

/*
　*  USB HIDBP Mouse support
　*/

#include <linux/kernel.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/usb/input.h>
#include <linux/hid.h>
/*
 * Version Information
　*/
#define DRIVER_VERSION "v1.6"
#define DRIVER_AUTHOR "Vojtech Pavlik <vojtech@ucw.cz>"
#define DRIVER_DESC "USB HID Boot Protocol mouse driver"
#define DRIVER_LICENSE "GPL"
MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_LICENSE(DRIVER_LICENSE);
/*
　* 鼠标结构体，用于描述鼠标设备。
　*/
struct usb_mouse
{
　　/* 鼠标设备的名称，包括生产厂商、产品类别、产品等信息 */
　　char name[128];
　　/* 设备节点名称 */
　　char phys[64];
　　/* USB 鼠标是一种 USB 设备，需要内嵌一个 USB 设备结构体来描述其 USB 属性 */
　　struct usb_device *usbdev;
　　/* USB 鼠标同时又是一种输入设备，需要内嵌一个输入设备结构体来描述其输入设备的属性 */
　　struct input_dev *dev;
　　/* URB 请求包结构体，用于传送数据 */
　　struct urb *irq;
　　/* 普通传输用的地址 */
　　signed char *data;
　　/* dma 传输用的地址 */
　　dma_addr_t data_dma;
};
/*
　* urb 回调函数，在完成提交 urb 后，urb 回调函数将被调用。
　* 此函数作为 usb_fill_int_urb 函数的形参，为构建的 urb 制定的回调函数。
　*/
static void usb_mouse_irq(struct urb *urb)
{
　　/*
　　* urb 中的 context 指针用于为 USB 驱动程序保存一些数据。比如在这个回调函数的形参没有传递在 probe
　　* 中为 mouse 结构体分配的那块内存的地址指针，而又需要用到那块内存区域中的数据，context 指针则帮了
　　* 大忙了！
　　* 在填充 urb 时将 context 指针指向 mouse 结构体数据区，在这又创建一个局部 mouse 指针指向在 probe
　　* 函数中为 mouse 申请的那块内存，那块内存保存着非常重要数据。
　　* 当 urb 通过 USB core 提交给 hc 之后，如果结果正常，mouse->data 指向的内存区域将保存着鼠标的按键
　　* 和移动坐标信息，系统则依靠这些信息对鼠标的行为作出反应。
　　* mouse 中内嵌的 dev 指针，指向 input_dev 所属于的内存区域。
　　*/
　　struct usb_mouse *mouse = urb->context;
　　signed char *data = mouse->data;
　　struct input_dev *dev = mouse->dev;
　　int status;
　　/*
　　* status 值为 0 表示 urb 成功返回，直接跳出循环把鼠标事件报告给输入子系统。
　　* ECONNRESET 出错信息表示 urb 被 usb_unlink_urb 函数给 unlink 了，ENOENT 出错信息表示 urb 被
　　* usb_kill_urb 函数给 kill 了。usb_kill_urb 表示彻底结束 urb 的生命周期，而 usb_unlink_urb 则
　　* 是停止 urb，这个函数不等 urb 完全终止就会返回给回调函数。这在运行中断处理程序时或者等待某自旋锁
　　* 时非常有用，在这两种情况下是不能睡眠的，而等待一个 urb 完全停止很可能会出现睡眠的情况。
　　* ESHUTDOWN 这种错误表示 USB 主控制器驱动程序发生了严重的错误，或者提交完 urb 的一瞬间设备被拔出。
　　* 遇见除了以上三种错误以外的错误，将申请重传 urb。
　　*/
　　switch (urb->status)
　　{
　　case 0:     /* success */
　　break;
　　case -ECONNRESET:   /* unlink */
　　case -ENOENT:
　　case -ESHUTDOWN:
　　return;
　　/* -EPIPE:  should clear the halt */
　　default:        /* error */
　　goto resubmit;
　　}
　　/*
　　* 向输入子系统汇报鼠标事件情况，以便作出反应。
　　* data 数组的第0个字节：bit 0、1、2、3、4分别代表左、右、中、SIDE、EXTRA键的按下情况；
　　* data 数组的第1个字节：表示鼠标的水平位移；
　　* data 数组的第2个字节：表示鼠标的垂直位移；
　　* data 数组的第3个字节：REL_WHEEL位移。
　　*/
　　input_report_key(dev, BTN_LEFT,   data[0] & 0x01);
　　input_report_key(dev, BTN_RIGHT,  data[0] & 0x02);
　　input_report_key(dev, BTN_MIDDLE, data[0] & 0x04);
　　input_report_key(dev, BTN_SIDE,   data[0] & 0x08);
　　input_report_key(dev, BTN_EXTRA,  data[0] & 0x10);
　　input_report_rel(dev, REL_X,     data[1]);
　　input_report_rel(dev, REL_Y,     data[2]);
　　input_report_rel(dev, REL_WHEEL, data[3]);
　　/*
　　* 这里是用于事件同步。上面几行是一次完整的鼠标事件，包括按键信息、绝对坐标信息和滚轮信息，输入子
　　* 系统正是通过这个同步信号来在多个完整事件报告中区分每一次完整事件报告。示意如下：
　　* 按键信息 坐标位移信息 滚轮信息 EV_SYC | 按键信息 坐标位移信息 滚轮信息 EV_SYC ...
　　*/
　　input_sync(dev);
　　/*
　　* 系统需要周期性不断地获取鼠标的事件信息，因此在 urb 回调函数的末尾再次提交 urb 请求块，这样又会
　　* 调用新的回调函数，周而复始。
　　* 在回调函数中提交 urb 一定只能是 GFP_ATOMIC 优先级的，因为 urb 回调函数运行于中断上下文中，在提
　　* 交 urb 过程中可能会需要申请内存、保持信号量，这些操作或许会导致 USB core 睡眠，一切导致睡眠的行
　　* 为都是不允许的。
　　*/
　　resubmit:
　　status = usb_submit_urb (urb, GFP_ATOMIC);
　　if (status)
　　err ("can't resubmit intr, %s-%s/input0, status %d",
　　mouse->usbdev->bus->bus_name,
　　mouse->usbdev->devpath, status);
　　}
　　/*
　　* 打开鼠标设备时，开始提交在 probe 函数中构建的 urb，进入 urb 周期。
　　*/
　　static int usb_mouse_open(struct input_dev *dev)
　　{
　　struct usb_mouse *mouse = dev->private;
　　mouse->irq->dev = mouse->usbdev;
　　if (usb_submit_urb(mouse->irq, GFP_KERNEL))
　　return -EIO;
　　return 0;
　　}
　　/*
　　* 关闭鼠标设备时，结束 urb 生命周期。
　　*/
　　static void usb_mouse_close(struct input_dev *dev)
　　{
　　struct usb_mouse *mouse = dev->private;
　　usb_kill_urb(mouse->irq);
　　}
　　/*
　　* 驱动程序的探测函数
　　*/
　　static int usb_mouse_probe(struct usb_interface *intf, const struct usb_device_id *id)
　　{
　　/*
　　* 接口结构体包含于设备结构体中，interface_to_usbdev 是通过接口结构体获得它的设备结构体。
　　* usb_host_interface 是用于描述接口设置的结构体，内嵌在接口结构体 usb_interface 中。
　　* usb_endpoint_descriptor 是端点描述符结构体，内嵌在端点结构体 usb_host_endpoint 中，而端点
　　* 结构体内嵌在接口设置结构体中。
  * usb_interface -> usb_host_interface -> usb_host_endpoint -> usb_endpoint_descriptor
  */
　　struct usb_device *dev = interface_to_usbdev(intf);
　　struct usb_host_interface *interface;
　　struct usb_endpoint_descriptor *endpoint;
　　struct usb_mouse *mouse;
　　struct input_dev *input_dev;
　　int pipe, maxp;
　　interface = intf->cur_altsetting;
　　/* 鼠标仅有一个 interrupt 类型的 in 端点，不满足此要求的设备均报错 */
　　if (interface->desc.bNumEndpoints != 1)
　　return -ENODEV;
　　endpoint = &interface->endpoint[0].desc;
　　if (!usb_endpoint_is_int_in(endpoint))
　　return -ENODEV;
　　/*
　　* 返回对应端点能够传输的最大的数据包，鼠标的返回的最大数据包为4个字节，数据包具体内容在 urb
　　* 回调函数中有详细说明。
　　*/
　　pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);
　　maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
　　/* 为 mouse 设备结构体分配内存 */
　　mouse = kzalloc(sizeof(struct usb_mouse), GFP_KERNEL);
　　/* input_dev */
　　input_dev = input_allocate_device();
　　if (!mouse || !input_dev)
　　goto fail1;
　　/*
　　* 申请内存空间用于数据传输，data 为指向该空间的地址，data_dma 则是这块内存空间的 dma 映射，
　　* 即这块内存空间对应的 dma 地址。在使用 dma 传输的情况下，则使用 data_dma 指向的 dma 区域，
　　* 否则使用 data 指向的普通内存区域进行传输。
　　* GFP_ATOMIC 表示不等待，GFP_KERNEL 是普通的优先级，可以睡眠等待，由于鼠标使用中断传输方式，
　　* 不允许睡眠状态，data 又是周期性获取鼠标事件的存储区，因此使用 GFP_ATOMIC 优先级，如果不能
　　* 分配到内存则立即返回 0。
　　*/
　　mouse->data = usb_buffer_alloc(dev, 8, GFP_ATOMIC, &mouse->data_dma);
　　if (!mouse->data)
　　goto fail1;
　　/*
　　* 为 urb 结构体申请内存空间，第一个参数表示等时传输时需要传送包的数量，其它传输方式则为0。
　　* 申请的内存将通过下面即将见到的 usb_fill_int_urb 函数进行填充。
　　*/
　　mouse->irq = usb_alloc_urb(0, GFP_KERNEL);
　　if (!mouse->irq)
　　goto fail2;
　　/* 填充 usb 设备结构体和输入设备结构体 */
　　mouse->usbdev = dev;
　　mouse->dev = input_dev;
　　/* 获取鼠标设备的名称 */
　　if (dev->manufacturer)
　　strlcpy(mouse->name, dev->manufacturer, sizeof(mouse->name));
　　if (dev->product)
　　{
　　if (dev->manufacturer)
　　strlcat(mouse->name, " ", sizeof(mouse->name));
　　strlcat(mouse->name, dev->product, sizeof(mouse->name));
　　}
　　if (!strlen(mouse->name))
　　snprintf(mouse->name, sizeof(mouse->name),
　　"USB HIDBP Mouse %04x:%04x",
　　le16_to_cpu(dev->descriptor.idVendor),
　　le16_to_cpu(dev->descriptor.idProduct));
　　/*
　　* 填充鼠标设备结构体中的节点名。usb_make_path 用来获取 USB 设备在 Sysfs 中的路径，格式
　　* 为：usb-usb 总线号-路径名。
　　*/
　　usb_make_path(dev, mouse->phys, sizeof(mouse->phys));
　　strlcat(mouse->phys, "/input0", sizeof(mouse->phys));
　　/* 将鼠标设备的名称赋给鼠标设备内嵌的输入子系统结构体 */
　　input_dev->name = mouse->name;
　　/* 将鼠标设备的设备节点名赋给鼠标设备内嵌的输入子系统结构体 */
　　input_dev->phys = mouse->phys;
　　/*
　　* input_dev 中的 input_id 结构体，用来存储厂商、设备类型和设备的编号，这个函数是将设备描述符
　　* 中的编号赋给内嵌的输入子系统结构体
　　*/
　　usb_to_input_id(dev, &input_dev->id);
　　/* cdev 是设备所属类别（class device） */
　　input_dev->cdev.dev = &intf->dev;
　　/* evbit 用来描述事件，EV_KEY 是按键事件，EV_REL 是相对坐标事件 */
　　input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_REL);
　　/* keybit 表示键值，包括左键、右键和中键 */
　　input_dev->keybit[LONG(BTN_MOUSE)] = BIT(BTN_LEFT) | BIT(BTN_RIGHT) | BIT(BTN_MIDDLE);
　　/* relbit 用于表示相对坐标值 */
　　input_dev->relbit[0] = BIT(REL_X) | BIT(REL_Y);
　　/* 有的鼠标还有其它按键 */
　　input_dev->keybit[LONG(BTN_MOUSE)] |= BIT(BTN_SIDE) | BIT(BTN_EXTRA);
　　/* 中键滚轮的滚动值 */
　　input_dev->relbit[0] |= BIT(REL_WHEEL);
　　/* input_dev 的 private 数据项用于表示当前输入设备的种类，这里将鼠标结构体对象赋给它 */
　　input_dev->private = mouse;
　　/* 填充输入设备打开函数指针 */
　　input_dev->open = usb_mouse_open;
　　/* 填充输入设备关闭函数指针 */
　　input_dev->close = usb_mouse_close;
　　/*
　　* 填充构建 urb，将刚才填充好的 mouse 结构体的数据填充进 urb 结构体中，在 open 中递交 urb。
　　* 当 urb 包含一个即将传输的 DMA 缓冲区时应该设置 URB_NO_TRANSFER_DMA_MAP。USB核心使用
　　* transfer_dma变量所指向的缓冲区，而不是transfer_buffer变量所指向的。
　　* URB_NO_SETUP_DMA_MAP 用于 Setup 包，URB_NO_TRANSFER_DMA_MAP 用于所有 Data 包。
　　*/
　　usb_fill_int_urb(mouse->irq, dev, pipe, mouse->data,
　　(maxp > 8 ? 8 : maxp),
　　usb_mouse_irq, mouse, endpoint->bInterval);
　　mouse->irq->transfer_dma = mouse->data_dma;
　　mouse->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
　　/* 向系统注册输入设备 */
　　input_register_device(mouse->dev);
　　/*
　　* 一般在 probe 函数中，都需要将设备相关信息保存在一个 usb_interface 结构体中，以便以后通过
　　* usb_get_intfdata 获取使用。这里鼠标设备结构体信息将保存在 intf 接口结构体内嵌的设备结构体中
　　* 的 driver_data 数据成员中，即 intf->dev->dirver_data = mouse。
　　*/
　　usb_set_intfdata(intf, mouse);
　　return 0;
　　fail2:  usb_buffer_free(dev, 8, mouse->data, mouse->data_dma);
　　fail1:  input_free_device(input_dev);
　　kfree(mouse);
　　return -ENOMEM;
　　}
　　/*
　　* 鼠标设备拔出时的处理函数
　　*/
　　static void usb_mouse_disconnect(struct usb_interface *intf)
　　{
　　/* 获取鼠标设备结构体 */
　　struct usb_mouse *mouse = usb_get_intfdata (intf);
　　/* intf->dev->dirver_data = NULL，将接口结构体中的鼠标设备指针置空。*/
　　usb_set_intfdata(intf, NULL);
　　if (mouse)
　　{
　　/* 结束 urb 生命周期 */
　　usb_kill_urb(mouse->irq);
　　/* 将鼠标设备从输入子系统中注销 */
　　input_unregister_device(mouse->dev);
　　/* 释放 urb 存储空间 */
　　usb_free_urb(mouse->irq);
　　/* 释放存放鼠标事件的 data 存储空间 */
　　usb_buffer_free(interface_to_usbdev(intf), 8, mouse->data, mouse->data_dma);
　　/* 释放存放鼠标结构体的存储空间 */
　　kfree(mouse);
　　}
　　}
　　/*
　　* usb_device_id 结构体用于表示该驱动程序所支持的设备，USB_INTERFACE_INFO 可以用来匹配特定类型的接口，
　　* 这个宏的参数意思为 (类别, 子类别, 协议)。
　　* USB_INTERFACE_CLASS_HID 表示是一种 HID (Human Interface Device)，即人机交互设备类别；
　　* USB_INTERFACE_SUBCLASS_BOOT 是子类别，表示是一种 boot 阶段使用的 HID；
　　* USB_INTERFACE_PROTOCOL_MOUSE 表示是鼠标设备，遵循鼠标的协议。
　　*/
　　static struct usb_device_id usb_mouse_id_table [] = {
　　{ USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,
　　USB_INTERFACE_PROTOCOL_MOUSE) },
　　{ } /* Terminating entry */
　　};
　　/*
　　* 这个宏用来让运行在用户空间的程序知道这个驱动程序能够支持的设备，对于 USB 驱动程序来说，第一个参数必须
　　* 是 usb。
　　*/
　　MODULE_DEVICE_TABLE (usb, usb_mouse_id_table);
　　/*
　　* 鼠标驱动程序结构体
　　*/
　　static struct usb_driver usb_mouse_driver = {
　　.name       = "usbmouse",
　　.probe      = usb_mouse_probe,
　　.disconnect = usb_mouse_disconnect,
　　.id_table   = usb_mouse_id_table,
　　};
　　/*
　　* 驱动程序生命周期的开始点，向 USB core 注册这个鼠标驱动程序。
　　*/
　　static int __init usb_mouse_init(void)
　　{
　　int retval = usb_register(&usb_mouse_driver);
　　if (retval == 0)
　　info(DRIVER_VERSION ":" DRIVER_DESC);
　　return retval;
　　}
　　/*
　　* 驱动程序生命周期的结束点，向 USB core 注销这个鼠标驱动程序。
　　*/
　　static void __exit usb_mouse_exit(void)
　　{
　　usb_deregister(&usb_mouse_driver);
　　}
　　module_init(usb_mouse_init);
　　module_exit(usb_mouse_exit);




























































