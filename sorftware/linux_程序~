/*************************** 动静态函数库 **************************/

.so 是动态函数库,.a是静态函数库,

linux 下编译链接默认为动态函数库.如果使用静态库链接,使用编译选项 -static: gcc -static test.c -o test  (-o 指定输出文件名字test)
如果编译时出现错误: cannot find -lc 指没有发现libc.a, l为lib简写

reedeld -d xxx 读出xxx使用了那些静态函数库

制作静态函数库:
gcc -c aaa.c -o aaa.o	编译出aaa.o执行文件
ar cqs libmylib.a aaa.0	打包到静态库 libmylib.a
拷贝 到 系统库目录 /usr/lib 里

gcc -static test.c -o test	相当于 gcc -static test.c -lc -o test	默认情况 编译只链接到静态c库, 
要使用别的静态态库,则要明确指出: gcc -static test.c -lmylib -o test	

gcc test.c -o test	相当于 gcc test.c -lc -o test	默认情况 编译只链接到动态c库, 
要使用别的动态态库,则要明确指出: gcc test.c -lmylib -o test	

制作动态函数库:
gcc -c aaa.c -o aaa.o	编译出aaa.o执行文件
gcc -shared -fPIC aaa.0	libmylib.so 打包到动态库 libmylib.so (-fPIC表示输出对象模块是按照可重定位地址方式生成的)
拷贝 到 系统库目录 /usr/lib 里

/*************************** 系统调用_文件编程 **************************/
见file_ops例子
这里使用的是linux 系统调用的函数操作.

/*************************** 库函数_文件编程 **************************/
见libc_file_ops例子
这里使用c函数库操作,方便,window inux 移植
函数先打开并操作一个流,并不是直接操作文件.

/*************************** 时间编程 **************************/
见time例子

/*************************** 进程 控制 编程 **************************/
临界区:一般指,每时每刻只允许一个进程或线程执行的代码段
进程同步:一组进程按照一定顺序执行,不允许后执行的先执行发生 
调度算法:先来先服务,短进程优先,高优先级优先,时间片轮转

/*************************** 无名管道 pipe**************************/
数据传输:无名管道pipe,有名管道FIFO,
资源共享:信号量
事件通知:信号(signal)
IPC(interprocess communication):unix进程间通信, 
				system V, 
				prosix(portable operating system interface)可移植,不局限于linux,可window 

pipe特点:
进程读空管道时进程阻塞,进程写满管道时进程阻塞,管道容量64kb
管道单向意思:只能从fd[1]写入数据,从fd[0]读出数据.
见pipe例子

fifo 特点:
同一时间,至少1个以O_WRONLY模式打开fifo,至少1个以O_RDONLY模式打开fifo,
如果进程都以同一个模式打开,那么都进程都被阻塞在打开函数里.
见fifo例子

注意给管道写入NULL,也算写入了一个字节,管道有一个实时计数器统计此时此刻的字节数量


/*************************** 信号(signal) **************************/
见signal例子.

/*************************** 信号量 permission denied 未解决 **************************/
信号量semaphore,见例子semaphore例子(互斥模型):现在主要出现了操作信号量时,permission denied 未解决

信号量属于ipc的一种子功能

关于键值:
每个ipc都有一个键值,进程通过键值找到信号量并访问,
由于每个键值对于整个linux系统唯一的,,键值的生成很讲究,如果自己任意指定一个数作为键值来使用,说不定已经被用了,而出现复用,而出现冲突,
所以,有巧妙的生成可用键值的方法:
	ftok(文件名,项目id),
	每个存在硬盘里的文件,(文件夹也是一个文件,里面包含列表信息)都有一个标识的唯一的文件名id号,
	文件名id号 + 项目id号 = 一个键值
	键值理解:
	每个执行隶属于同一个项目的并行进程,都要访问同一个文件或文件夹内容时,都需要一个并行访问的机制,有序访问目标内容,
	这个机制由共同遵守的同一和唯一的键值,所提供的各类IPC子功能共同实现,
	并行进程,隶属于同一个项目,都要访问相同的资源,就已经表现出遵守的同一和唯一的某个键值 的行为!

信号量的典型使用 互斥模型:
	多个进程访问同一个资源或文件时,先获取信号量,信号量会-1,当信号量为0时,表示,正被别的进程使用,
	当某进程用完后,释放信号量,信号量+1,别的进程检测到正值,便可以访问文件或资源了.


现在主要出现了操作信号量时,permission denied 未解决


信号量的典型使用 同步模型
生产者,释放信号量,消费者提取信号量,且信号量初始值一定为0
这样,生产者完才释放信号量,消费者才可以提取信号量,然后获取生产好的产品,
这时信号量回归0,等下一次生产者生产完产品释放信号量,消费者才可以再次消费产品.

同步模型中,如果确保,生产者程序,一定先与消费者程序执行,那么,信号量创建并初始化为0的操作可以放到生产者程序里,
不然就得有一个第三方程序创建并初始化信号量为零

semctl(semid,2,SETVAL,0);	//把信号量集semid的编号2的信号量设置为0.


/*************************** 共享内存 **************************/
见share_memory例子

先创建共享内存,然后映射到用户内存,
注意,只能root状态下运行,依然出现权限问题


/*************************** 消息队列 **************************/
见message例子
注意,read write 同时在root状态下才能正常运行,运行,依然出现权限问题

/*************************** 多线程 互斥锁 条件变量 (多线程返回值引起的core-dump 未解决)**************************/
与创建自己的的进程共享代码和数据段,
但有自己独立的栈
进程一旦结束,其生成的线程也强制异常退出,所以进程要等线程都结束才可以结束


见thread例子:

使用线程时,编译时必须链接到pthread库: gcc -lpthread 错误,尽管网上都这么教,
				     gcc -pthread 正确,通过 man read_create 发现

线程互斥:使线程有纪律访问共同资源
使用互斥锁 mutex

线程同步:使线程按顺序执行
使用条件变量 cond

/*************************** 网络编程 **************************/
linux只使用了,tcp/ip的4层模型,(非osi的7层模型):应用层,传输层,网络层,网络接口层

liuux 网络模型 基于socket这种套接字特殊文件模型的

见net例子


字节序
小端模式:数据从低地址开始放,
大端模式:数据从高地址开始放
网络发送数据按大端模式,也称为网络字节序

如果机子属于小端模式,通过网络发数据时,要都先转成大端模式(网络字节序)
即主机字节序转成网络字节序 

htonl(uint32_t hostlong)	//32位数据从主机字节序转成网络字节序  (假设主机字节序是小端模式)
htonl(uint16_t hostshort)	//16位数据从主机字节序转成网络字节序  

ntohl(uint32_t hostlong)	//32位数据从网络字节序转成主机字节序  (假设主机字节序是小端模式)
ntohs(uint32_t hostlong)	//16位数据从网络字节序转成主机字节序











